hpeKrMG-WP0
https://www.youtube.com/watch?v=hpeKrMG-WP0
Unknown Category
In this video, I'm going to introduce state space equations, the model representation of choice for modern control. However, before we begin, a quick warning. We're not going to go into depth on the mathematics of state space. After this video, you're probably not going to be able to write out the equations for any arbitrary system. But what I think you will get is a good intuitive understanding of these equations, which can be a foundation that you can build on as you learn more. At the very least, it might clear up a few lingering questions you might have. So with that in mind, let's get to it. I'm Brian, and welcome to a MATLAB Tech Talk. I think an interesting thing about dynamic systems is that they can be represented by ordinary differential equations. This is because they have this property that how the system is changing at any given time is a function of its current state. If we zip through the derivation for a spring-mass system real quick, you can see we end up with a differential equation. Now the way that the system is changing, acceleration, is a function of the current state, position. If this dynamic system was initialized with some energy, it would continue to move on its own because of this relationship between the derivative of the state and the state itself. Think about initializing this system by stretching the spring and letting it go. Acceleration changes velocity, which changes position, and then that changes acceleration again. And it's going to oscillate back and forth without you having to add any external inputs. Since there's no damping in this system, the energy is conserved, and this acceleration-velocity-position cycle will continue forever. For any arbitrary dynamic system, if we look at how the energy changes by analyzing the relationship between its states and their derivatives, we can make claims about things like the stability of the system. Is the energy being dissipated over time? Then the system is stable. And the faster the energy is dissipated, the more stable it is. If the energy is growing unbounded over time, even for just a part of it, then the system as a whole is unstable. Energy is an inherent property of a system simply from the way that the states and their derivatives are connected to each other. The way the system moves, however, can also be influenced by external energy being added or removed over time. So the derivatives of a dynamic system are a function of both the current state as well as any external inputs. In state space, representation is simply a repackaging of the high-order differential equations into a set of first-order differential equations that focus on this relationship. This repackaging can make the system easier to analyze because we can look at the underlying behavior of the interconnected system as well as how the system is affected by external inputs, even multiple external inputs, which is really powerful. There are also a lot of control techniques that are built on state space models, like Kalman filtering, LQR control, robust control, and model predictive control to just name a few. There are also numerical solution benefits when simulating your system as a state space model, since you build the vector of the derivatives first and then integrate the whole vector to get the states. So all in all, they're pretty awesome and worth learning. Now let's take a moment to look at the state space equations in more detail and try to make a little sense of them. For this, we'll focus on the continuous form for a linear time-invariant system. There are two equations. The first one is the state equation, which we've already developed a little intuition around, and the second equation is the output equation, which I'll get to in just a bit. State space representation is built around the state vector x. This is a vector of all of the state variables. And how the state vector changes, or the derivative of the state vector, is a linear combination of the current state plus a linear combination of the external inputs. In this way, we're not trying to look at the entire dynamics of the system end-to-end like we would with a high-order differential equation or a transfer function, but rather focus on the dynamics of each state variable, and how those variables relate to each other. How does the first state change as a function of all of the states and all of the inputs? How does the second state change as a function of all of the states and inputs? And so on. And since we're only ever looking at the first derivative of each state, we end up with a set of first-order differential equations. What we're left with is a system of linear equations that we can package into matrix form. And if linear algebra is good for anything, it's definitely solving a system of linear equations. It is this repackaging into matrix form that gives us access to a lot of mathematical tools that we didn't have before. The matrix form of the state equation has two matrices, A and B. The A matrix describes how the internal states are all connected to each other, the underlying dynamics of the system. And the B matrix describes how the inputs enter into the system, which states are they affecting. Now let's look at the output equation. Y is a vector of the outputs of the system, or the part that you're interested in knowing. The important thing to realize is that the outputs are not necessarily the state variables. The C matrix describes how the states are combined to get the outputs. And the D matrix is used to allow the inputs to bypass the system altogether and feed forward to the output. A real simple example of the D matrix in action would be the state space representation of a simple multiplier, a gain block. The output equals the input times the gain. So in this way the A, B, and C matrices are all zero, since there are no derivatives and no states. And the D matrix is the value of the gain. Now the importance of the output equation will become obvious when we start feeding back the outputs to develop a closed loop controller for our system. But for now it's enough to understand the structure of the equation. And in the next video on feedback control we'll go into more depth on the relationship between the output and state equations. As you might have noticed, the state variables are the key to the whole thing. They show up in three places and are the part of the representation that I think is the hardest to conceptualize. Therefore understanding what they are is really important. The state variables are the minimum set of variables that fully describe the system. Fully described means that we have enough information about the changing part of the system, or the variable part, that we can predict the system's future behavior. This will make more sense if we go back to the spring mass system and suss out what the state variables are by starting with no information about the system. If I draw the spring and mass like this and asked you to predict where the system will be in one second, what information would you need? Well, you'd want to know the system constants, like the spring constant and mass, and we'd want to know what the external force is that's acting on the mass, so the inputs. But this only tells you part of the story because you don't know what you might call the initial conditions for the variable parts of the system. Is the mass currently moving? And how hard is the spring pulling on the mass? Now if we knew these two starting conditions, along with the system constants and inputs, then we would be able to predict where the mass would be after one second. So let's consider the first question. Is the mass currently moving? We would know this from the velocity of the mass. And velocity is variable since the mass would be oscillating back and forth, assuming there was some energy in the system. So we need velocity in order to predict the future position, so we can say that velocity is a state variable. It's necessary. Now let's turn to the initial spring force. Force is also a variable, but let's think about how we would derive it. It's the spring constant times the distance that the spring is stretched. So if we have that distance, or the position of the mass relative to the unstretched length of spring, then we would be able to get spring force. So the minimum number of variables we need to fully describe this system is two, position and velocity. And since there are two, this is a second order system. So a natural question now might be why not more states? Why not three? Well to answer that, let's consider acceleration. It's a variable since it's changing along with position and velocity. However, we don't need to know acceleration to fully describe the system. Acceleration is a result of force acting on a mass. And force, in this case, is a byproduct of the position of the mass. Therefore, we get acceleration through position, and adding acceleration to your list of state variables is just extra information. Now something that might seem strange at first is that if we add a damper into the system, we're not increasing the order of the system, because we don't need any additional state variables to account for this additional element. The force from the damper is determined by the velocity of the mass, which, again, we already have in our state variable list. So both of these systems have the same number of state variables, too. Now a way you can verify that you have the right number of states needed to describe a system is to count the energy storage devices that your system has. Now I'm not going to go into too much detail here, because I think Dr. Rick Hill has done a great job of explaining it in his YouTube video that I've linked in the description below. But the general idea is this. A dynamic system stores energy in various ways. In our spring mass system, there's two energy storage elements. The spring, which stores potential energy, and the mass, which stores kinetic energy. The dynamic system moves and changes on its own simply because the energy that exists within the system transfers back and forth between storage elements and eventually dissipates through heat, which is ultimately lost to the environment. At any given time, if we know how much energy is stored in each element, then we know its state, and have the information needed to fully understand the state of the system. Now, the states don't represent the energy directly. They're just needed to determine the energy. For the spring mass system, we know the energy in the mass from the velocity of the mass. And we know the energy in the spring from the position, or how far the spring is stretched. And if we know how those energies are connected within the system, or another way of putting it, how each state absorbs and loses energy based on the current state of the system, then we fully understand the system itself. And this is essentially what state space representation is doing for us. It's looking at the state variables, how the energy is stored, and combining them according to how energy is transferred between states, and adding in any additional energy from the external sources. And with a few special caveats that Professor Hill describes, that is why the number of energy storage elements in your system equals the number of states. So our spring mass damper is still a second order system, since a damper doesn't store energy, it just dissipates it. So, we know the order has to be 2, but why not 2 different states? Why position and velocity? Well, they don't have to be, and here's where things can get a little confusing. The state variables, position and velocity, can be thought of as coordinate systems within a state space. Go over 5 position units, and up 3 velocity units. This point in the state space is the current state of the system, and the state vector describes that location. So we can describe this location in the state space with any two linearly independent variables, some arbitrary state 1 and state 2. We're going to end up with the same system state in the end, it's the same energy, just with different coordinates. And we do this redefining of state variables all the time with state space representation. That's what we're doing, for example, when we diagonalize the A matrix to get it into so-called modal form. We've just chosen a different set of coordinates, a different basis for our state vector. So, state vector x is made up of position and velocity, and state vector z is made up of two modal states, and these particular states change as a function of just themselves. That is, state 1 does not rely on the current value of state 2, and vice versa. And if we were able to write out the state's base representation directly in modal form, then maybe we would. There's nothing really special about position and velocity for state variables, other than they are quantities that make intuitive sense to us. However, since the states are no longer defined as position and velocity, the C matrix needs to change if we want to keep the outputs position and velocity. In this way we can see the benefit of the output equation. We're not forced to output the states exactly as we define them, but rather have the ability to linearly combine them into variables that we're interested in. Okay, that's where I'm going to leave this video for now. I hope this has helped you think about the state's base equations in a slightly different way. Rather than thinking of them as a set of matrices that repackage the model into arbitrary first order differential equations, we can think about them as writing out the dynamics for each state variable separately. And the dynamics are tied to how energy is stored and transferred within the system. By doing this we get the benefit of being able to understand how these internal states change and relate to each other. How the energy is moving around and we get to use the powerful tools in linear algebra to analyze and solve the equations. Now MATLAB and Simulink are great environments to work with states-based systems. You can convert to states-based from a transfer function, manipulate the matrices, simulate them, and design and analyze control systems using a number of built-in tools. And I'm going to be using MATLAB to demonstrate control techniques with states-based equations for the rest of this series. So if you're not familiar with using states-based in MATLAB, or if you're looking for a quick refresher, I've linked a few videos in the description that are worth checking out. In the next video in this series, I'll go through the design of a simple feedback control system using states-based representation. If you don't want to miss the next Tech Talk video, don't forget to subscribe to this channel. Also, if you want to check out my channel, Control System Lectures, I cover more control theory topics there as well. Thanks for watching, and I'll see you next time.