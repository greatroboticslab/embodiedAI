1
00:00:00,400 --> 00:00:04,000
In this video, we're going to talk about a way to develop a feedback controller for

2
00:00:04,000 --> 00:00:06,840
a model that's represented using state space equations.

3
00:00:06,840 --> 00:00:12,320
And we're going to do that with a method called pole placement, or full state feedback.

4
00:00:12,320 --> 00:00:17,020
Now my experience is that pole placement itself isn't used extensively in industry.

5
00:00:17,020 --> 00:00:21,760
You might find that you're using other methods like LQR or H infinity more often.

6
00:00:21,760 --> 00:00:25,380
However, pole placement is worth spending some time on because it will give you a better

7
00:00:25,380 --> 00:00:30,340
understanding of the general approach to feedback control using state space equations.

8
00:00:30,340 --> 00:00:33,580
And it's a stepping stone to getting to those other methods.

9
00:00:33,580 --> 00:00:35,040
So I hope you stick around.

10
00:00:35,040 --> 00:00:39,580
I'm Brian, and welcome to a MATLAB Tech Talk.

11
00:00:39,580 --> 00:00:44,180
To start off, we have a plant with inputs U and outputs Y.

12
00:00:44,180 --> 00:00:49,140
And the goal is to develop a feedback control system that drives the output to some desired

13
00:00:49,140 --> 00:00:50,140
value.

14
00:00:50,140 --> 00:00:54,460
A way you might be familiar with doing this is to compare the output to a reference signal

15
00:00:54,460 --> 00:00:56,620
to get the control error.

16
00:00:56,620 --> 00:01:01,160
Then you can develop a controller that uses that error to generate the input signals into

17
00:01:01,160 --> 00:01:04,800
the plant with the goal of driving the error to zero.

18
00:01:04,800 --> 00:01:09,020
This is the structure of the feedback control system that you would see if you were developing,

19
00:01:09,020 --> 00:01:11,840
say, a PID controller.

20
00:01:11,840 --> 00:01:16,140
But for pole placement, we're going to approach this problem in a different way.

21
00:01:16,140 --> 00:01:20,920
Rather than feedback the output Y, we're going to feedback the value of every state variable

22
00:01:20,920 --> 00:01:21,920
in our state vector.

23
00:01:21,920 --> 00:01:25,580
Now we're going to claim that we know the value of every state, even though it's not

24
00:01:25,580 --> 00:01:27,760
necessarily part of the output Y.

25
00:01:27,760 --> 00:01:29,760
And we'll get to that in a bit.

26
00:01:29,760 --> 00:01:33,640
But for now, assume we have access to all of these values.

27
00:01:33,640 --> 00:01:37,920
We then take the state vector and multiply it by a matrix that is made up of a bunch of

28
00:01:37,920 --> 00:01:39,840
different gain values.

29
00:01:39,840 --> 00:01:43,720
And the result is subtracted from a scaled reference signal.

30
00:01:43,720 --> 00:01:48,080
And this result is fed directly into our plant as the input.

31
00:01:48,080 --> 00:01:53,240
Now, you'll notice that there isn't a block here labeled controller, like we have in the

32
00:01:53,240 --> 00:01:55,160
top block diagram.

33
00:01:55,160 --> 00:01:59,080
In this feedback structure, this whole section is the controller.

34
00:01:59,080 --> 00:02:04,620
And pole placement is a method by which we can calculate the proper gain matrix to guarantee

35
00:02:04,620 --> 00:02:06,580
system stability.

36
00:02:06,580 --> 00:02:11,080
And the scaling term on the reference is used to ensure that steady state error performance

37
00:02:11,080 --> 00:02:12,080
is acceptable.

38
00:02:12,080 --> 00:02:15,820
I'll cover both of these in this video.

39
00:02:15,820 --> 00:02:18,260
But first we need some background information.

40
00:02:18,260 --> 00:02:22,960
In the last video we introduced the state equation x dot equals ax plus bu.

41
00:02:22,960 --> 00:02:28,240
And we showed that the dynamics of a linear system are captured in this first part, ax.

42
00:02:28,240 --> 00:02:32,900
The second part is how the system responds to inputs, but how the energy in the system

43
00:02:32,900 --> 00:02:36,840
is stored and moves is captured by the ax term.

44
00:02:36,840 --> 00:02:40,580
So, you might expect that there is something special about the A matrix when it comes to

45
00:02:40,580 --> 00:02:42,360
controller design.

46
00:02:42,360 --> 00:02:43,920
And there is.

47
00:02:43,920 --> 00:02:48,080
Any feedback controller has to modify the A matrix in order to change the dynamics of

48
00:02:48,080 --> 00:02:49,200
the system.

49
00:02:49,200 --> 00:02:52,920
And this is especially true when it comes to stability.

50
00:02:52,920 --> 00:02:56,680
The eigenvalues of the A matrix are the poles of the system.

51
00:02:56,680 --> 00:03:00,600
And the location of the poles dictate stability of a linear system.

52
00:03:00,600 --> 00:03:03,680
And that's the key to pole placement.

53
00:03:03,680 --> 00:03:07,360
And then we can calculate the required closed loop stability by moving the poles, or the

54
00:03:07,360 --> 00:03:10,460
eigenvalues, of the closed loop A matrix.

55
00:03:10,460 --> 00:03:14,960
Now I want to expand a bit more on the relationship between poles and eigenvalues and stability before

56
00:03:14,960 --> 00:03:19,300
we go any further, because I think it will help you understand exactly how pole placement

57
00:03:19,300 --> 00:03:21,300
works.

58
00:03:21,300 --> 00:03:26,540
For this example, let's just start with an arbitrary system and focus on the dynamics,

59
00:03:26,540 --> 00:03:28,000
the A matrix.

60
00:03:28,000 --> 00:03:32,500
We can rewrite this in non-matrix form so it's a little bit easier to see how the state derivatives

61
00:03:32,500 --> 00:03:34,460
relate to the states.

62
00:03:34,460 --> 00:03:38,020
In general, each state can change as a function of the other states.

63
00:03:38,020 --> 00:03:39,840
And that's the case here.

64
00:03:39,840 --> 00:03:46,280
x.1 changes based on x2, and x.2 changes based on both x1 and x2.

65
00:03:46,280 --> 00:03:48,360
And this is perfectly acceptable.

66
00:03:48,360 --> 00:03:52,440
But it makes it a little hard to visualize how eigenvalues are contributing to the overall

67
00:03:52,440 --> 00:03:53,720
dynamics.

68
00:03:53,720 --> 00:03:59,000
So what we can do is transform the A matrix into one that uses a different set of state

69
00:03:59,000 --> 00:04:01,960
variables to describe the system.

70
00:04:01,960 --> 00:04:06,940
This transformation is accomplished using a transform matrix, whose columns are the eigenvectors

71
00:04:06,940 --> 00:04:08,580
of the A matrix.

72
00:04:08,580 --> 00:04:14,240
And what we end up with after the transformation is a modified A matrix consisting of the complex

73
00:04:14,240 --> 00:04:18,900
eigenvalues along the diagonal and zeros everywhere else.

74
00:04:18,900 --> 00:04:22,740
Now, these two models represent the exact same system.

75
00:04:22,740 --> 00:04:25,520
They have the same eigenvalues and the same dynamics.

76
00:04:25,520 --> 00:04:30,620
It's just the second one is described using a set of state variables that change independently

77
00:04:30,620 --> 00:04:32,340
of each other.

78
00:04:32,340 --> 00:04:36,280
When the A matrix is written in diagonal form, it's easy to see that what we're left with

79
00:04:36,280 --> 00:04:41,580
is a set of first order differential equations where the derivative of each state is only affected

80
00:04:41,580 --> 00:04:44,480
by that state, and nothing else.

81
00:04:44,480 --> 00:04:46,080
And here's the cool part.

82
00:04:46,080 --> 00:04:51,220
The solution to a differential equation like this is in the form z equals a constant times

83
00:04:51,220 --> 00:04:58,820
e to the lambda t, where lambda is the eigenvalue for that given state variable.

84
00:04:58,820 --> 00:05:03,180
Okay, let's dive into this equation a little bit more.

85
00:05:03,180 --> 00:05:09,100
z in shows how the state changes over time given some initial condition, c.

86
00:05:09,100 --> 00:05:13,320
Or another way of thinking about this is that if you initialize the state with some energy,

87
00:05:13,320 --> 00:05:18,940
or you add energy from an external input, this equation shows how that energy changes.

88
00:05:18,940 --> 00:05:24,360
And by changing lambda, you can affect how the energy is dissipated, or in the case of an

89
00:05:24,360 --> 00:05:27,120
unstable system, how the energy grows.

90
00:05:27,120 --> 00:05:30,840
So let's go through a few different values of lambda so you can visually see how energy

91
00:05:30,840 --> 00:05:35,900
changes based on the location of the eigenvalue within the complex plane.

92
00:05:35,900 --> 00:05:42,120
If lambda is a negative real number, then this is a stable eigenvalue since the solution

93
00:05:42,120 --> 00:05:47,400
is e raised to a negative number, and any initial energy will dissipate over time.

94
00:05:47,400 --> 00:05:52,680
But if it's positive, then it's unstable because the energy will just grow over time.

95
00:05:52,680 --> 00:05:57,240
And if there's a pair of imaginary eigenvalues, then the energy in this mode will oscillate,

96
00:05:57,240 --> 00:06:02,020
since e raised to an imaginary number produces sines and cosines.

97
00:06:02,020 --> 00:06:07,300
And any combination of the two, of real and imaginary numbers, will produce a combination

98
00:06:07,300 --> 00:06:11,880
of oscillations and exponential energy dissipation.

99
00:06:11,880 --> 00:06:16,360
Now I know this was all very fast, but hopefully it made enough sense that now we can state the

100
00:06:16,360 --> 00:06:18,440
problem we're trying to solve.

101
00:06:18,440 --> 00:06:23,640
If our plant has eigenvalues that are at undesirable locations in the complex plane, then we can use

102
00:06:23,640 --> 00:06:27,220
pole placement to move them somewhere else.

103
00:06:27,220 --> 00:06:31,860
Now certainly if they're in the right half plane it's undesirable since they'd be unstable,

104
00:06:31,860 --> 00:06:36,280
but undesirable could also mean there's oscillations you want to get rid of, or maybe just speed

105
00:06:36,280 --> 00:06:41,420
up or slow down the dissipation of energy in a particular mode.

106
00:06:41,420 --> 00:06:46,460
With that behind us, we can now get into how pole placement moves the eigenvalues.

107
00:06:46,460 --> 00:06:49,720
Remember the structure of the controller that we drew at the beginning?

108
00:06:49,720 --> 00:06:58,220
Well this results in an input u equals rkr minus k times x, where rkr is the scaled reference,

109
00:06:58,220 --> 00:07:03,080
which again we'll get to in a bit, and kx is the state vector that we're feeding back

110
00:07:03,080 --> 00:07:05,400
multiplied by the gain matrix.

111
00:07:05,400 --> 00:07:07,800
Now here's where the magic happens.

112
00:07:07,800 --> 00:07:12,460
If we plug this control input into our state equation, we're closing the loop and we get

113
00:07:12,460 --> 00:07:15,860
the following state equation.

114
00:07:15,860 --> 00:07:21,220
Notice that a and minus bk both act on the state vector, so we can combine them to get

115
00:07:21,220 --> 00:07:23,900
a modified a matrix.

116
00:07:23,900 --> 00:07:27,900
This is the closed loop a matrix, and we have the ability to move the eigenvalues by

117
00:07:27,900 --> 00:07:30,080
choosing an appropriate k.

118
00:07:30,080 --> 00:07:33,400
And this is easy to do by hand for simple systems.

119
00:07:33,400 --> 00:07:37,140
Let's try an example with a second order system with a single input.

120
00:07:37,140 --> 00:07:43,680
We can find the eigenvalues by setting the determinant of a minus lambda i to 0, and then solve for

121
00:07:43,680 --> 00:07:44,680
lambda.

122
00:07:44,680 --> 00:07:48,060
And they're at minus 2 and plus 1.

123
00:07:48,060 --> 00:07:52,960
One of the modes will blow up to infinity because of the presence of the positive real eigenvalue,

124
00:07:52,960 --> 00:07:56,260
and so the system as a whole is unstable.

125
00:07:56,260 --> 00:08:00,940
Let's use pole placement to design a feedback controller that will stabilize this system

126
00:08:00,940 --> 00:08:04,720
by moving the unstable pole to the left half plane.

127
00:08:04,720 --> 00:08:10,500
Our closed loop A matrix is A minus Bk, and the gain matrix k is a 1 by 2 since there's

128
00:08:10,500 --> 00:08:12,700
one output in two states.

129
00:08:12,700 --> 00:08:18,900
This results in minus k1, 1 minus k2, 2, and minus 1.

130
00:08:18,900 --> 00:08:23,580
And we can solve for the eigenvalues of ACL like we did before, and we get this characteristic

131
00:08:23,580 --> 00:08:28,080
equation that's a function of our two gain values.

132
00:08:28,080 --> 00:08:32,940
Now let's say that we want our closed loop poles at minus 1 and minus 2.

133
00:08:32,940 --> 00:08:37,600
In this way, the characteristic equation needs to be lambda squared plus 3 times lambda plus

134
00:08:37,600 --> 00:08:40,140
2 equals 0.

135
00:08:40,140 --> 00:08:44,340
And at this point, it's straightforward to find the appropriate k1 and k2 that make

136
00:08:44,340 --> 00:08:47,240
these two equations equal.

137
00:08:47,240 --> 00:08:50,420
We just set the coefficients equal to each other and solve.

138
00:08:50,420 --> 00:08:55,860
And we get k1 equals 2 and k2 equals 1.

139
00:08:55,860 --> 00:08:57,580
And that's it.

140
00:08:57,580 --> 00:09:02,260
If we place these two gains in the state feedback path of this system, it will be stabilized

141
00:09:02,260 --> 00:09:06,380
with eigenvalues at minus 1 and minus 2.

142
00:09:06,380 --> 00:09:10,540
Walking through an example by hand I think gives you a good understanding of pole placement

143
00:09:10,540 --> 00:09:12,220
and how it works.

144
00:09:12,220 --> 00:09:16,660
However, the math involved starts to become overwhelming for systems that have more than

145
00:09:16,660 --> 00:09:18,020
two states.

146
00:09:18,020 --> 00:09:22,620
The idea is the same, just solving the determinant becomes impractical.

147
00:09:22,620 --> 00:09:27,340
But we can do this exact same thing in MATLAB with pretty much a single command.

148
00:09:27,340 --> 00:09:31,520
I'll show you quickly how to use the place command in MATLAB by recreating the same system

149
00:09:31,520 --> 00:09:33,200
that we just did by hand.

150
00:09:33,200 --> 00:09:38,200
I'll define the four matrices, and then create the open loop state space object.

151
00:09:38,200 --> 00:09:42,280
I can check the eigenvalues of the open loop A matrix just to show you that there is in

152
00:09:42,280 --> 00:09:47,280
fact that positive eigenvalue that causes the system to be unstable.

153
00:09:47,280 --> 00:09:48,620
And that's no good.

154
00:09:48,620 --> 00:09:53,680
So let's move the eigenvalues of the system to minus 2 and minus 1.

155
00:09:53,680 --> 00:09:58,520
Now solving for the gain matrix using pole placement can be done with the place command.

156
00:09:58,520 --> 00:10:03,200
And we get gain values of 2 and 1 just like we expected.

157
00:10:03,200 --> 00:10:07,540
Now the new closed loop A matrix is A minus BK.

158
00:10:07,540 --> 00:10:12,540
And just to double check, this is what ACL looks like, and it does have eigenvalues at

159
00:10:12,540 --> 00:10:15,200
minus 1 and minus 2.

160
00:10:15,200 --> 00:10:16,200
OK.

161
00:10:16,200 --> 00:10:20,560
I'll create the closed loop system object, and now we can compare the step responses for

162
00:10:20,560 --> 00:10:21,880
both.

163
00:10:21,880 --> 00:10:26,820
The step response of the open loop system is predictably unstable.

164
00:10:26,820 --> 00:10:29,900
And the step response of the closed loop system looks much better.

165
00:10:29,900 --> 00:10:32,720
However, it's not perfect.

166
00:10:32,720 --> 00:10:38,940
Rather than rising to 1 like we would expect, the steady state output is only 0.5.

167
00:10:38,940 --> 00:10:43,480
And this is finally where the scaling term comes in on the reference.

168
00:10:43,480 --> 00:10:47,700
So far we've only been concerned with stability, and have paid little attention to steady state

169
00:10:47,700 --> 00:10:49,040
performance.

170
00:10:49,040 --> 00:10:52,000
But even addressing this is pretty straightforward.

171
00:10:52,000 --> 00:10:56,940
If the response of the input is only half of what you would expect, why not just double

172
00:10:56,940 --> 00:10:58,580
the input?

173
00:10:58,580 --> 00:11:00,160
And that's pretty much what we do.

174
00:11:00,160 --> 00:11:02,260
Well, we're not just doubling it.

175
00:11:02,260 --> 00:11:07,720
We scale the input by the inverse of the steady state value.

176
00:11:07,720 --> 00:11:11,680
In MATLAB we can do this by inverting the DC gain of the system.

177
00:11:11,680 --> 00:11:16,820
You can see that the DC gain is 0.5, and so the inverse is 2.

178
00:11:16,820 --> 00:11:22,980
Now we can rebuild our closed loop system by scaling the input by kr, or by 2, and checking

179
00:11:22,980 --> 00:11:24,480
the step response.

180
00:11:24,480 --> 00:11:27,780
And no surprise, its steady state value is 1.

181
00:11:27,780 --> 00:11:30,940
And that's pretty much what there is to basic pole placement.

182
00:11:30,940 --> 00:11:35,260
We feedback every state variable and multiply them by a gain matrix in such a way that the

183
00:11:35,260 --> 00:11:39,820
closed loop eigenvalues are what we want, and then we scale the input to make the steady

184
00:11:39,820 --> 00:11:42,480
state response what we want.

185
00:11:42,480 --> 00:11:46,920
Of course there's more to pole placement than what I could cover in this 12 minute video.

186
00:11:46,920 --> 00:11:50,680
And I don't want to drag this on too long, but I also don't want to leave this video

187
00:11:50,680 --> 00:11:54,480
without addressing a few more interesting things for you to consider.

188
00:11:54,480 --> 00:11:59,660
So in the interest of time, let's blast through these final thoughts lightning round style.

189
00:11:59,660 --> 00:12:00,760
Are you ready?

190
00:12:00,760 --> 00:12:02,380
Let's go.

191
00:12:02,380 --> 00:12:05,000
Pole placement is like fancy root locus.

192
00:12:05,000 --> 00:12:09,140
With root locus, you have one gain that you can adjust that can only move the poles along

193
00:12:09,140 --> 00:12:10,660
the locus lines.

194
00:12:10,660 --> 00:12:14,780
But with pole placement, we have a gain matrix that gives us the ability to move the poles

195
00:12:14,780 --> 00:12:20,140
anywhere in the complex plane, not just along single dimensional lines.

196
00:12:20,140 --> 00:12:24,660
A two-state pole placement controller is very similar to a PD controller.

197
00:12:24,660 --> 00:12:29,500
With PD, you feed back the output and generate the derivative within the controller.

198
00:12:29,500 --> 00:12:33,560
With pole placement, you are feeding back the derivative as a state, but the results are

199
00:12:33,560 --> 00:12:35,040
essentially the same.

200
00:12:35,040 --> 00:12:39,120
Two gains, one for a state, and one for its derivative.

201
00:12:39,120 --> 00:12:44,120
Okay, we can move eigenvalues around, but where should we place them?

202
00:12:44,120 --> 00:12:48,640
The answer to that is a much longer video, but here are some things to think about.

203
00:12:48,640 --> 00:12:53,280
If you have a high order system, consider keeping two poles closer to the imaginary axis than

204
00:12:53,280 --> 00:12:57,360
the others so that the system will behave like a common second order system.

205
00:12:57,360 --> 00:13:01,540
These are called dominant poles since they are slower and tend to dominate the response

206
00:13:01,540 --> 00:13:02,740
of the system.

207
00:13:02,740 --> 00:13:08,200
Keep in mind that if you try to move a bunch of eigenvalues really far left in order to

208
00:13:08,200 --> 00:13:12,420
get a super fast response, you may find that you don't have the speed or authority in

209
00:13:12,420 --> 00:13:15,640
your actuators to generate the necessary response.

210
00:13:15,640 --> 00:13:20,480
This is because it takes more gain, or more actuator effort, to move the eigenvalues further

211
00:13:20,480 --> 00:13:24,240
from their open loop starting points.

212
00:13:24,240 --> 00:13:27,020
Full state feedback is a bit of a misnomer.

213
00:13:27,020 --> 00:13:30,080
You are feeding back every state in your mathematical model.

214
00:13:30,080 --> 00:13:33,800
But you don't, and can't, feed back every state in a real system.

215
00:13:33,800 --> 00:13:39,320
For just one example, at some level all mechanical hardware is flexible, which means additional

216
00:13:39,320 --> 00:13:43,220
states, but you may choose to ignore those states in your model and develop your feedback

217
00:13:43,220 --> 00:13:45,820
controller assuming a rigid system.

218
00:13:45,820 --> 00:13:49,340
The important part is that you feed back all critical states to your design, so that your

219
00:13:49,340 --> 00:13:53,240
controller will still work on the real hardware.

220
00:13:53,240 --> 00:13:57,520
You have to have some kind of access to all of the critical states in order to feed them

221
00:13:57,520 --> 00:13:58,520
back.

222
00:13:58,520 --> 00:14:02,400
The output Y might include every state, in which case you're all set.

223
00:14:02,400 --> 00:14:06,400
However, if this isn't the case, you will either need to add more sensors to your system

224
00:14:06,400 --> 00:14:11,860
to measure the missing states, or use the existing outputs to estimate or observe the states you

225
00:14:11,860 --> 00:14:13,600
aren't measuring directly.

226
00:14:13,600 --> 00:14:16,980
In order to observe your system, it will need to be observable.

227
00:14:16,980 --> 00:14:20,520
And similarly, in order to control your system, it needs to be controllable.

228
00:14:20,520 --> 00:14:50,520


229
00:14:50,520 --> 00:14:54,400
I'll see you next time.

230
00:14:54,400 --> 00:14:58,280
Thank you.

