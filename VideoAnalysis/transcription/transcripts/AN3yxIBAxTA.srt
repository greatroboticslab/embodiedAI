1
00:00:00,960 --> 00:00:04,560
This is a brushless motor one-axis PID control example.

2
00:00:05,680 --> 00:00:10,320
In general, all flying machines use this kind of feedback control in order to fly straight.

3
00:00:11,600 --> 00:00:17,200
To control the inclination angle, the system uses the MPU6050 gyro and accelerometer

4
00:00:17,200 --> 00:00:19,920
and to control the movement, these two brushless motors.

5
00:00:21,680 --> 00:00:27,600
The idea of this tutorial is to understand how PID control works inside of a drone flight controller

6
00:00:27,600 --> 00:00:32,640
in order to be able to create our own flight controller code for the fully Arduino based project.

7
00:00:34,080 --> 00:00:35,200
So let's get started.

8
00:00:45,920 --> 00:00:47,840
What's up my friends, welcome back.

9
00:00:48,880 --> 00:00:53,280
In this video we will see an example of PID control for one axis movement.

10
00:00:53,280 --> 00:01:01,040
Once we see how the control works for just one axis, we could apply the code for two axis in case of a drone.

11
00:01:02,640 --> 00:01:05,840
The first thing to do is to build a balance for our test.

12
00:01:07,120 --> 00:01:10,800
For that I've used a 55 cm long square meter bar.

13
00:01:12,160 --> 00:01:14,480
I've drilled a hole exactly in the middle.

14
00:01:15,440 --> 00:01:19,200
Then I've passed an 8 mm screw through the hole and through some bearings.

15
00:01:19,200 --> 00:01:26,320
I fit in place the two bearings to a wood support and screw in place this wood support to a wood base.

16
00:01:28,320 --> 00:01:32,080
The only thing left is to make some holes in both ends of the metal bar.

17
00:01:33,680 --> 00:01:37,920
Through these holes I'll pass some zip ties and tighten place two brushless motors.

18
00:01:39,760 --> 00:01:42,240
The motors are connected following this schematic.

19
00:01:42,240 --> 00:01:49,200
I've soldered the ESCs to each motor and make sure that the motors will spin in these directions.

20
00:01:51,360 --> 00:01:56,720
I've soldered together the supply wires of each ESCs and added a LiPo connector to the end.

21
00:01:58,240 --> 00:02:05,840
To supply the motors you could use a 3S LiPo battery or as in my case a PC power supply with 12V output,

22
00:02:05,840 --> 00:02:09,440
since I will be using the motors for a long time for multiple tests.

23
00:02:11,200 --> 00:02:16,720
Now the next step is to add the Arduino microcontroller and the MPU 6050 IMU board.

24
00:02:18,400 --> 00:02:24,720
Using a breadboard I make these connections from the Arduino to the module and connect ground and signal to the two ESCs.

25
00:02:26,320 --> 00:02:31,200
Now make sure that you place the IMU board as center as you can between the two motors.

26
00:02:31,200 --> 00:02:37,600
I've used a small balsa wood board and some double side tape to fit everything in place.

27
00:02:39,840 --> 00:02:41,440
Now the circuit is ready.

28
00:02:42,560 --> 00:02:45,760
The MPU 6050 I2C connection is done.

29
00:02:46,480 --> 00:02:50,480
The ESC signals are connected and the power supply is ready to go.

30
00:02:52,160 --> 00:02:54,720
The only thing left is to program the Arduino.

31
00:02:56,560 --> 00:02:59,200
Ok, so let's understand what PID control is.

32
00:02:59,200 --> 00:03:04,560
PID stands for proportional, integral and derivative control.

33
00:03:06,400 --> 00:03:11,520
In our case we want to control the angle of the metal bar since we want the drone to fly straight,

34
00:03:11,520 --> 00:03:13,760
horizontal and without wobbling around.

35
00:03:16,000 --> 00:03:22,560
These brushless motors are very powerful and any small change of power will spin the metal bar to the left or to the right.

36
00:03:24,480 --> 00:03:27,280
We need a fast and accurate control of the angle.

37
00:03:29,840 --> 00:03:34,480
Ok, so the MPU 6050 module will give us gyro and acceleration data.

38
00:03:35,760 --> 00:03:40,640
Using this data and applying some filters we obtain the real inclination angle of the metal bar.

39
00:03:42,320 --> 00:03:46,560
We will see the entire code and how to obtain the data and the angle a little bit later.

40
00:03:48,000 --> 00:03:49,840
First, let's see how we will proceed.

41
00:03:49,840 --> 00:03:58,880
Ok, so we know the real angle of the metal bar and we want it to stay always at 0 degrees which is perfectly horizontal.

42
00:04:00,240 --> 00:04:04,160
The maximum angle to the right will be in this case around 45 degree.

43
00:04:04,160 --> 00:04:13,840
Ok, so let's imagine now that we power up the motors with no control at all.

44
00:04:15,200 --> 00:04:18,720
The brushless motors will be always different respecting the power.

45
00:04:18,720 --> 00:04:30,480
It's almost impossible to have the same output power for the same signal since the motors are mechanical things and even a small difference will make a motor have more power than the other one.

46
00:04:30,480 --> 00:04:37,200
So even with the same speed signal the metal bar will lean to the direction of the less powerful motor.

47
00:04:38,720 --> 00:04:42,400
In this case, the PID control will work in the following way.

48
00:04:42,400 --> 00:04:48,000
I think this is the most common representation of a PID control that you could find.

49
00:04:49,680 --> 00:04:56,000
As you can see, we have our process that in this case will be the movement of the motors to keep the metal bar horizontal.

50
00:04:57,200 --> 00:05:03,920
After the process, we have our feedback to the system that in this case is the real angle that the IMU unit will give us.

51
00:05:06,080 --> 00:05:09,120
Now we first have to calculate the error of our control.

52
00:05:09,120 --> 00:05:15,440
This error is the difference between a desired value and the real value of the system.

53
00:05:16,880 --> 00:05:25,040
In our case, our desired value is zero degree angle of the metal bar and the real value is the data received from the IMU unit.

54
00:05:26,800 --> 00:05:30,560
So, the first thing to do is to create a variable and name it error.

55
00:05:32,320 --> 00:05:36,560
We will give the difference value between the real angle and zero to this variable.

56
00:05:36,560 --> 00:05:40,560
Now we have our error value in each loop.

57
00:05:42,640 --> 00:05:46,240
The next step in the PID control is to use these three constants.

58
00:05:47,600 --> 00:05:55,600
These constants are Kp, Ki and Kd as for proportional constants, integrate constants and derivative constant.

59
00:05:56,720 --> 00:06:02,880
The total output of the PID control is the sum of these three parts, proportional, integrate and derivative.

60
00:06:02,880 --> 00:06:07,360
The total output of the PID control is the sum of these two constants.

61
00:06:09,600 --> 00:06:15,280
Ok, so let's start with the integrate and derivative constants equal to zero and the proportional to one.

62
00:06:17,040 --> 00:06:20,880
In this case, the output of the PID control will be the error itself.

63
00:06:20,880 --> 00:06:34,800
Now we know that we should apply a 1000 microseconds to 2000 microseconds signal to the ESC in order to spin the motors where 1000 is no spinning at all and 2000 is full throttle.

64
00:06:36,240 --> 00:06:39,360
These values may vary depending on your used ESC.

65
00:06:39,360 --> 00:06:50,720
Now let's imagine that we make the motor spin at low speed by applying a signal of 1200 microseconds, which is around 20% throttle.

66
00:06:51,280 --> 00:06:54,080
Plus or minus the output of the PID control.

67
00:06:54,080 --> 00:07:01,760
I say plus or minus because to the right side we have positive values of the angle and in the left side negative.

68
00:07:02,320 --> 00:07:09,200
So we have to sum the PID value to the right motor and subtract the PID output to the left motor in order to balance the power.

69
00:07:11,200 --> 00:07:18,320
We power up the system and let's say that at the beginning the left motor will push a little bit harder making the metal bar lean to the right.

70
00:07:18,320 --> 00:07:24,240
As the bar leans to the right the PID value increase proportional to the angle.

71
00:07:25,680 --> 00:07:34,320
As bigger the angle gets the right motor will spin faster each time and the left motor slower since we sum the PID value to one and subtract it to the other.

72
00:07:36,480 --> 00:07:39,200
That will make the bar start leaning to the opposite side.

73
00:07:40,720 --> 00:07:45,920
And here, once again following the same process we will start leaning to the right side and so on.

74
00:07:45,920 --> 00:07:52,880
This will create an oscillating movement of the bar that will maybe stabilize after a long time.

75
00:07:55,120 --> 00:07:59,200
The oscillation is too slow with the proportional constant equal to 1.

76
00:07:59,200 --> 00:08:02,720
So after some tests I define it to 3 and this is the result.

77
00:08:04,720 --> 00:08:06,080
Seems pretty good for now.

78
00:08:08,160 --> 00:08:12,400
What we need now is to fast react at the speed of movement of the bar.

79
00:08:12,400 --> 00:08:18,480
In this case it's not the angle that we will control but the speed in degrees per second.

80
00:08:20,480 --> 00:08:27,680
So our code will also count the elapsed time of each loop and by dividing the angle difference by this time we will get the speed.

81
00:08:29,680 --> 00:08:34,960
Now we have to multiply this speed by the derivative constant which in this case won't be zero anymore.

82
00:08:34,960 --> 00:08:40,560
I set the derivative constant too high and the system gets crazy.

83
00:08:42,080 --> 00:08:44,000
Set it to low and it won't affect.

84
00:08:45,840 --> 00:08:51,600
To cancel both effects I'll make the PAT output to be the sum of the proportional and derivative values.

85
00:08:51,600 --> 00:08:58,960
After some tests I've set the derivative constant to 2 and the result was quite good.

86
00:09:00,320 --> 00:09:05,200
Now the system stabilizes itself quite well with a good response to the fast speed changes.

87
00:09:07,360 --> 00:09:10,000
Then what will the integral part add to the system?

88
00:09:10,000 --> 00:09:17,200
Well, for very small angles the proportional constant won't affect anymore or the value will be very small.

89
00:09:17,680 --> 00:09:21,840
And if the metal bar is not moving the derivative constant won't affect neither.

90
00:09:23,760 --> 00:09:27,040
So the bar could get stabilized but not perfect horizontal.

91
00:09:29,040 --> 00:09:33,840
For that we add the integrate constant that gets bigger and bigger as more time is elapsed.

92
00:09:33,840 --> 00:09:35,680
So the bar is the first.

93
00:09:35,840 --> 00:09:43,200
To show you how this works I will keep the bar lean to the right and observe that each time the right motor spins faster and the left one slower.

94
00:09:44,880 --> 00:09:48,560
That's because each loop the integral value increase a little bit more.

95
00:09:50,560 --> 00:09:56,080
This will fine tune our PID control when the angle is very small and the speed is almost zero.

96
00:09:56,080 --> 00:10:04,240
The integral constant usually is very low. In my case 0.048 was a good value.

97
00:10:06,560 --> 00:10:14,800
For our drone flight controller you could even not use the integral constant and make the PID output just the sum of the proportional and derivative values.

98
00:10:17,360 --> 00:10:23,600
Now that I've explained you how each part of the PID control works, I've made a bunch of tests and changing the values

99
00:10:23,600 --> 00:10:32,640
and my best result was Kp equal to 3.44, Kd equal to 1.92 and Ki equal to 0.048.

100
00:10:35,040 --> 00:10:40,160
These PID constants will change depending of the shape, weight and size of the system.

101
00:10:40,160 --> 00:10:43,840
So when we will add the second axis these values will definitely change.

102
00:10:46,240 --> 00:10:49,440
Ok, so let's now take a look at the code that I've used.

103
00:10:49,440 --> 00:10:50,480
I'll show you how to use the code that I've used.

104
00:10:50,480 --> 00:10:51,040
I'll show you how to use the code that I've used.

105
00:10:51,040 --> 00:10:54,800
You could download all the schematics, codes and examples using the link below.

106
00:10:56,560 --> 00:10:59,680
Also check my webpage for more details of the tutorial.

107
00:11:02,080 --> 00:11:07,360
Ok, the first thing to do is to import the libraries and define our motors, the right and the left one.

108
00:11:09,440 --> 00:11:16,800
If we study the NPU6050 datasheet and the register map, we will see that it will give us 3 values for the acceleration

109
00:11:16,800 --> 00:11:21,520
and 3 values for the gyro data, one for each of the x, y and z axes.

110
00:11:23,200 --> 00:11:25,680
We will store those values in these constants.

111
00:11:27,680 --> 00:11:34,000
In order to obtain a good real angle, we will have to add a filter between the angle obtained with the gyro values

112
00:11:34,000 --> 00:11:36,000
and the one obtained with the accelerations.

113
00:11:36,000 --> 00:11:44,400
We can get the total angle using this formula where we can obtain the gyro angle directly with the IMU values

114
00:11:44,400 --> 00:11:49,920
and the acceleration angle using the Euler formula and finally applying the complementary filter.

115
00:11:51,680 --> 00:11:55,600
This is a real data graphic made with the NPU6050 values.

116
00:11:57,360 --> 00:12:04,640
The yellow line is the real angle and as you can see it's way better having less errors than using just gyro or acceleration values.

117
00:12:06,000 --> 00:12:08,400
That's why we are using the complementary filter.

118
00:12:10,080 --> 00:12:16,000
Ok, now in the setup loop we write the minimum values to the motors and add a delay of 7 seconds

119
00:12:16,000 --> 00:12:18,880
to give us time to connect the power supply to the motors.

120
00:12:20,960 --> 00:12:26,000
In the void loop, as we talked before, we measure the real elapsed time using the millis function.

121
00:12:28,160 --> 00:12:32,880
We will use this elapsed time to calculate the speed in the derivative part of the PID.

122
00:12:32,880 --> 00:12:42,480
Now we send the slave address to the IMU module which is 0x68 and send the first direction of the acceleration data.

123
00:12:44,880 --> 00:12:51,120
Since each value for each axis is divided in two 8-bit registers, we ask for 6 registers.

124
00:12:52,640 --> 00:13:00,240
Once we receive those 6 registers, we combine the high and low part of each in order to obtain the x, y and z accelerations.

125
00:13:00,240 --> 00:13:12,160
Now, in order to convert these values to g's, we divide them by 16384 since this is the values that the module gives us for 1g accelerations.

126
00:13:14,320 --> 00:13:17,760
Using this Euler formula, we obtain the acceleration angles.

127
00:13:17,760 --> 00:13:27,520
Now, we ask for the gyro data and divide that value by 131 as the datasheet tells us in order to obtain degrees per second.

128
00:13:28,960 --> 00:13:34,880
If we multiply these values by the elapsed time and sum the value each loop, we obtain the inclination angle.

129
00:13:36,640 --> 00:13:43,520
Finally, we calculate the real total angle applying the complementary filter between the gyro angle and the acceleration angles.

130
00:13:43,520 --> 00:13:47,440
Here we start the PID control.

131
00:13:48,720 --> 00:13:53,040
Remember that we will use just one angle because this is a one axis test.

132
00:13:54,800 --> 00:14:01,760
In this case, I've used the y axis because in the way I've placed the IMU module, that is the parallel axis with the metal bar.

133
00:14:01,760 --> 00:14:06,320
First, we calculate the error as mentioned before.

134
00:14:07,520 --> 00:14:10,480
We create the proportional value of the PID control.

135
00:14:12,000 --> 00:14:20,240
Next, we create the integral value and finally the derivative values dividing the subtraction between the last error and the actual error by the elapsed time.

136
00:14:20,240 --> 00:14:25,040
That will give us the speed in degrees per second.

137
00:14:27,280 --> 00:14:31,120
Finally, the total PID output is the sum of these 3 parts.

138
00:14:32,800 --> 00:14:41,600
Now we have to give a maximum and minimum range for the PID, since the motors could only accept values between 1000 and 2000 microseconds.

139
00:14:41,600 --> 00:14:44,720
Now we apply that range here.

140
00:14:46,400 --> 00:14:49,680
We calculate the throttle and write these values to each motor.

141
00:14:51,360 --> 00:14:56,400
Remember that we have to add the PID output to one motor and subtract it to the other one.

142
00:14:58,240 --> 00:14:59,120
We are done.

143
00:14:59,120 --> 00:15:00,880
The PID control is ready.

144
00:15:02,480 --> 00:15:05,600
The drone could now fly straight even if I push it around.

145
00:15:05,600 --> 00:15:10,320
As you could see, the metal bar gets always horizontal.

146
00:15:12,000 --> 00:15:17,840
If we change the desired angle when we calculate the error, we could stabilize the bar in any other angle.

147
00:15:19,680 --> 00:15:25,600
This is not the perfect PID control, but fine tuning the constants, you could always obtain the best results.

148
00:15:27,520 --> 00:15:32,400
In next videos, we will see how to adapt this code for our flight controller and for two axes.

149
00:15:32,400 --> 00:15:38,400
Also, how to change the desired angle depending on the received values from the radio controller of the drone.

150
00:15:40,560 --> 00:15:45,200
I hope that you learned how PID works for drones and also for any other system.

151
00:15:46,640 --> 00:15:49,440
If you like this video, click the like button like crazy.

152
00:15:50,320 --> 00:15:54,080
Also, share my videos with your friends because that will help my channel a lot.

153
00:15:55,760 --> 00:16:00,640
Don't forget to subscribe and also consider helping my projects on my new Patreon page.

154
00:16:02,400 --> 00:16:06,960
If you have any questions, just leave it in the comment section below or my Q&A page.

155
00:16:08,560 --> 00:16:10,960
Thanks again and see you later guys!

