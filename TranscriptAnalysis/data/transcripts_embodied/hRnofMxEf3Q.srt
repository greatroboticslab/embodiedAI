1
00:00:00,000 --> 00:00:02,800
Ah, the inverted pendulum.

2
00:00:02,800 --> 00:00:09,400
Getting one of these to work is a little bit of a rite of passage if you're studying engineering or more specifically control theory.

3
00:00:09,400 --> 00:00:11,800
The concept is fairly straightforward.

4
00:00:11,800 --> 00:00:17,100
We have a weight or in this case a simple metal rod that can move freely about an axis.

5
00:00:17,100 --> 00:00:23,800
And as you can see here, once the program stopped, it just freely fell over because it's in an unstable position when it's upright.

6
00:00:23,800 --> 00:00:35,200
But our job is to create a controller that takes in encoder values that is the angle in which this rod is pointing and then controls the stepper motor so that it stays upright.

7
00:00:35,200 --> 00:00:38,400
We won't try to do the swing up where it gets it into that position.

8
00:00:38,400 --> 00:00:41,900
We'll just assume that it starts in the upright position in our controller.

9
00:00:41,900 --> 00:00:43,600
We'll need to keep it there.

10
00:00:43,600 --> 00:00:48,200
The Arduino in this case is just going to act as an interface for us.

11
00:00:48,200 --> 00:00:53,400
It's going to read in values from the encoder and then send commands to control the stepper motor.

12
00:00:53,400 --> 00:01:01,200
All of our coding will be done in Python for the controller so that we can make pretty graphs and it will help us tune the controller more easily.

13
00:01:01,200 --> 00:01:03,800
So with that in mind, let's get started.

14
00:01:09,900 --> 00:01:18,700
A PID controller is an instrument device or code that uses feedback from a sensor to regulate a process or system.

15
00:01:18,700 --> 00:01:29,500
PID stands for proportional integral derivative, which describes how the feedback information is used to create a control signal for the process.

16
00:01:29,500 --> 00:01:36,700
If you would like to dive more into the theory behind PID controllers, I highly recommend checking out my previous video.

17
00:01:36,700 --> 00:01:45,700
In our system, we want our pendulum to sit upright, which we're going to call 180 degrees, and we'll use a PID controller to make that happen.

18
00:01:45,700 --> 00:01:55,700
The input to the controller is the error term, which is the difference between our desired set point and the actual sensor value or feedback.

19
00:01:55,700 --> 00:02:01,700
The output of the controller is used as the input signal to our process or plant.

20
00:02:01,700 --> 00:02:06,700
In this case, it will be how many degrees we want to move our stepper motor by.

21
00:02:06,700 --> 00:02:10,700
The process gives us some kind of value to measure.

22
00:02:10,700 --> 00:02:17,700
In this case, it is an encoder angle, which is used in the feedback loop to compute the error term.

23
00:02:17,700 --> 00:02:21,700
In some cases, we can mathematically model the process.

24
00:02:21,700 --> 00:02:26,700
Many inverted pendulums can be modeled if you know the weight, size and so on.

25
00:02:26,700 --> 00:02:34,700
However, in many real world situations, it is very difficult or impossible to model the system we want to control.

26
00:02:34,700 --> 00:02:38,700
So we turn to manual tuning methods for our controller.

27
00:02:38,700 --> 00:02:42,700
While there are several tuning methods, we'll stick with the most basic.

28
00:02:42,700 --> 00:02:51,700
First, we'll set the integral and derivative constants to zero and guess at some value for the proportional constant.

29
00:02:51,700 --> 00:02:56,700
With a Kp too low, we won't get anywhere near our set point.

30
00:02:56,700 --> 00:03:03,700
We then adjust it so that our output gets close to the set point with maybe some oscillations.

31
00:03:03,700 --> 00:03:10,700
From there, we tune Ki so that we oscillate around the set point without causing the system to become unstable.

32
00:03:10,700 --> 00:03:14,700
In many cases, a Pi controller is enough.

33
00:03:14,700 --> 00:03:20,700
However, we can often tune the Kd term to remove some of that overshoot.

34
00:03:20,700 --> 00:03:25,700
With Kp, Ki, and Kd set, we have a fully tuned system.

35
00:03:25,700 --> 00:03:30,700
Here, the output quickly approaches the set point without overshooting.

36
00:03:30,700 --> 00:03:32,700
We'll run some code on the Arduino.

37
00:03:32,700 --> 00:03:36,700
Remember that the Arduino is simply acting as an interface for us.

38
00:03:36,700 --> 00:03:39,700
It's not doing any of the actual control code for us.

39
00:03:39,700 --> 00:03:46,700
It's going to read in values from the encoder and send out information necessary to control the stepper motor.

40
00:03:46,700 --> 00:03:52,700
If we scroll down to the top here of our code, we are using the L6474.

41
00:03:52,700 --> 00:03:55,700
That's an STMicroelectronics code.

42
00:03:55,700 --> 00:03:59,700
That's a library for our Arduino that allows us to control the stepper motor.

43
00:03:59,700 --> 00:04:05,700
We're also using a library called rotary encoder that just gives us angle information from that coder.

44
00:04:05,700 --> 00:04:10,700
If we click over to the control comms interface file, scroll down a little bit.

45
00:04:10,700 --> 00:04:15,700
You can see we have an object here control comms and there should be two basic functions.

46
00:04:15,700 --> 00:04:18,700
Well, we have our constructor and our unit.

47
00:04:18,700 --> 00:04:24,700
We also have send observation, which sends information back to the PC.

48
00:04:24,700 --> 00:04:28,700
In our case, it's just the angle of the encoder as well as the angle of the stepper motor.

49
00:04:28,700 --> 00:04:30,700
In addition, we have receive action.

50
00:04:30,700 --> 00:04:34,700
This just waits for an action to come from the PC that says what to do.

51
00:04:34,700 --> 00:04:46,700
We're going to put in this our angle that we want to move the stepper motor by, say, for example, move by three degrees or negative three degrees in the opposite direction.

52
00:04:46,700 --> 00:04:53,700
So if we go to our main interface program here, scroll down to where we see setup, we configure everything.

53
00:04:53,700 --> 00:05:00,700
And then in loop, we simply wait for those actions to show up for us from the PC side.

54
00:05:00,700 --> 00:05:05,700
We move the stepper as requested, say, by a certain number of degrees.

55
00:05:05,700 --> 00:05:08,700
We get the encoder and stepper angles.

56
00:05:08,700 --> 00:05:14,700
We put those into an array and then we send that observation back to the PC.

57
00:05:14,700 --> 00:05:22,700
And that is our entire loop and how we're going to control our inverted pendulum on the Python or the PC side of things.

58
00:05:22,700 --> 00:05:24,700
We have our control comms interface.

59
00:05:24,700 --> 00:05:29,700
This is the PC version of that control comms HPP file that we looked at.

60
00:05:29,700 --> 00:05:32,700
In this case, we have a similar object called control comms.

61
00:05:32,700 --> 00:05:37,700
We can get a list of serial ports, which helps us figure out what we need to connect to.

62
00:05:37,700 --> 00:05:42,700
We can connect to our serial port, which opens up a connection to the Arduino board.

63
00:05:42,700 --> 00:05:45,700
We can close that connection.

64
00:05:45,700 --> 00:05:50,700
And then the important thing here is this step function for us.

65
00:05:50,700 --> 00:06:01,700
We give it an action and some sort of command, say, move by or move to or reset, which says to make whatever position the stepper motor is in home.

66
00:06:01,700 --> 00:06:03,700
That information gets sent to the Arduino.

67
00:06:03,700 --> 00:06:09,700
The Arduino performs that action and then returns an observation to us, which is a status.

68
00:06:09,700 --> 00:06:13,700
In this case, it's just some user defined code that we're not going to use very much.

69
00:06:13,700 --> 00:06:19,700
A timestamp, which is useful to see how long it takes to compute some things, whether it's terminated.

70
00:06:19,700 --> 00:06:20,700
Once again, we're not really using that here.

71
00:06:20,700 --> 00:06:21,700
And an observation.

72
00:06:21,700 --> 00:06:26,700
In this case, it's going to be the angle of the encoder and the angle of the stepper motor.

73
00:06:26,700 --> 00:06:31,700
You can see that code here where we send out the command along with the action.

74
00:06:31,700 --> 00:06:32,700
We wait for a response.

75
00:06:32,700 --> 00:06:37,700
We decode that in JSON format and then we return with those results.

76
00:06:37,700 --> 00:06:41,700
Here's the status timestamp terminated and our observation array.

77
00:06:41,700 --> 00:06:44,700
And this is just for testing down here.

78
00:06:44,700 --> 00:06:47,700
Now let's look at the actual PID controller code.

79
00:06:47,700 --> 00:06:49,700
This is the part we care about.

80
00:06:49,700 --> 00:07:02,700
I'm going to execute these cells, but I won't get into the code very much because I want to spend more time on tuning the controller where we fiddle with the constants in order to make the inverted pendulum work.

81
00:07:02,700 --> 00:07:05,700
So from the top here, we're just going to import some libraries.

82
00:07:05,700 --> 00:07:06,700
We're going to set our constants.

83
00:07:06,700 --> 00:07:09,700
In this case, my Arduino is connected to com six.

84
00:07:09,700 --> 00:07:19,700
I'm using a baud rate of 500 K and I have assigned a timeout of one second in case something doesn't work where I can't communicate with that Arduino board.

85
00:07:19,700 --> 00:07:26,700
I also set my debug level here so that I can get some information from my control comms Python library that I've created.

86
00:07:26,700 --> 00:07:32,700
We've got some communication constants that we will be using.

87
00:07:32,700 --> 00:07:36,700
In this case, we're going to be using stepper mode eight, which is eight divisions per step.

88
00:07:36,700 --> 00:07:43,700
And we have some commands we can send out, such as setting home, move to move by and setting our stepper mode.

89
00:07:43,700 --> 00:07:45,700
I'm going to close that connection to the Arduino.

90
00:07:45,700 --> 00:07:46,700
That's just a safety thing.

91
00:07:46,700 --> 00:07:50,700
Make sure it is actually closed and then I'm going to reopen that connection.

92
00:07:50,700 --> 00:07:53,700
So now I can talk to the Arduino board.

93
00:07:53,700 --> 00:08:01,700
First, I'm going to test the control to make sure that it actually moves.

94
00:08:01,700 --> 00:08:13,700
The idea here is that the stepper motor should be able to move fast enough such that it can recover from a, say, plus or minus 10 degree offset from being vertical.

95
00:08:13,700 --> 00:08:20,700
If we go back to our Arduino code here, you can see the configuration that I set up for the stepper motor.

96
00:08:20,700 --> 00:08:29,700
I'm using the ST microelectronics L6474 library, and I've set the acceleration to very high.

97
00:08:29,700 --> 00:08:32,700
It should get up to max speed very quickly.

98
00:08:32,700 --> 00:08:37,700
I've set the maximum speed to 5000, which is about half of their maximum.

99
00:08:37,700 --> 00:08:49,700
That seems to be a good compromise between giving me a very high speed that it can correct for a 10 degree offset from vertical while not being very jittery in its motion.

100
00:08:49,700 --> 00:08:50,700
So you want to find that balance.

101
00:08:50,700 --> 00:08:54,700
So I played with these parameters to find a good balance.

102
00:08:54,700 --> 00:08:56,700
Note that this can take some time.

103
00:08:56,700 --> 00:09:03,700
And I was just doing this by feel before moving on and tuning the PID controller.

104
00:09:03,700 --> 00:09:09,700
Once we verified that this control works, it's time to tune the controller.

105
00:09:09,700 --> 00:09:12,700
Here I've set up my K constants.

106
00:09:12,700 --> 00:09:13,700
Here's PID.

107
00:09:13,700 --> 00:09:19,700
Sometimes you will need a bias, which we just add to our output of the controller.

108
00:09:19,700 --> 00:09:24,700
In many cases, a P controller is fine and you just need a simple bias and this will do it.

109
00:09:24,700 --> 00:09:28,700
Sometimes you'll find that even with PID, there's a little bit of an offset.

110
00:09:28,700 --> 00:09:30,700
So you add a bias term.

111
00:09:30,700 --> 00:09:34,700
We may not need that for this particular project, but just keep that in mind.

112
00:09:34,700 --> 00:09:38,700
There are other constants that you should keep in mind.

113
00:09:38,700 --> 00:09:40,700
Our set point is 180.

114
00:09:40,700 --> 00:09:41,700
That's 180 degrees.

115
00:09:41,700 --> 00:09:43,700
That's the rod facing up.

116
00:09:43,700 --> 00:09:47,700
We're going to run this for, let's say, 5000 steps.

117
00:09:47,700 --> 00:09:50,700
That's a good indication of whether this is working or not.

118
00:09:50,700 --> 00:09:53,700
We have guard degrees here.

119
00:09:53,700 --> 00:09:56,700
So we want the rod at 180 degrees.

120
00:09:56,700 --> 00:10:03,700
At 160 degrees or 200 degrees, we assume that the rod has fell over far enough and it's a lost cause.

121
00:10:03,700 --> 00:10:08,700
And the program or in this case, this particular cell will just stop.

122
00:10:08,700 --> 00:10:11,700
We're going to do eight divisions per step.

123
00:10:11,700 --> 00:10:20,700
That seems to be, once again, a good balance between having the stepper motor move quickly while still giving us enough control without having a lot of jitter.

124
00:10:20,700 --> 00:10:25,700
We're going to store the metrics so that we can plot them later.

125
00:10:25,700 --> 00:10:30,700
The first thing we're going to do is set the stepper mode to those eight divisions per step.

126
00:10:30,700 --> 00:10:34,700
And then we're going to set home wherever the stepper motor is facing.

127
00:10:34,700 --> 00:10:36,700
We're going to call that zero degrees.

128
00:10:36,700 --> 00:10:39,700
We're going to send that out and get our first time step.

129
00:10:39,700 --> 00:10:42,700
Then we'll try to keep the pendulum in the upright position.

130
00:10:42,700 --> 00:10:44,700
This is the actual PID controller.

131
00:10:44,700 --> 00:10:47,700
We'll first take a step and get that observation.

132
00:10:47,700 --> 00:10:51,700
So we take a step by telling the stepper motor to move by some amount.

133
00:10:51,700 --> 00:10:56,700
This move degree starts off as zero and that's what gets updated as the output of our controller.

134
00:10:56,700 --> 00:11:05,700
When we get our response, we're going to unpack that response to get status, time step terminated and our observation, which is an array.

135
00:11:05,700 --> 00:11:07,700
We unpack that array here.

136
00:11:07,700 --> 00:11:12,700
The first element of that array is the encoder degrees, and that's what we really care about.

137
00:11:12,700 --> 00:11:14,700
The second is our stepper degrees.

138
00:11:14,700 --> 00:11:27,700
Note that you could create a dual PID controller here, whether that's an inner and outer or side by side controllers, where you can then try to keep your stepper motor in the same spot rather than rotating.

139
00:11:27,700 --> 00:11:32,700
But instead of doing two controllers, we're going to keep it very simple and just do our one controller.

140
00:11:32,700 --> 00:11:34,700
Consider that a challenge for you.

141
00:11:34,700 --> 00:11:42,700
If you want to take this further, try to keep the stepper motor in more or less one position rather than having it spin around that axis.

142
00:11:42,700 --> 00:11:49,700
We're going to calculate the time between this step and the previous to get our interval, which we need in some of our calculations.

143
00:11:49,700 --> 00:11:55,700
And then we're going to record the previous time step so that we can use it on the next iteration of this loop.

144
00:11:55,700 --> 00:11:57,700
Then we're going to calculate our PID terms.

145
00:11:57,700 --> 00:12:05,700
We'll first find the error, which is the difference between our set point and the current encoder degrees, which we got from the observation.

146
00:12:05,700 --> 00:12:13,700
This error term is going to be used in our proportional calculations where we just multiply it by K P.

147
00:12:13,700 --> 00:12:19,700
Next up, we get the integral term, which takes the integral term from last time.

148
00:12:19,700 --> 00:12:25,700
This starts at zero and we accumulate that value with the error times our interval.

149
00:12:25,700 --> 00:12:33,700
From there, we get our derivative term, which is the previous error subtracted from the current error and divided by our time interval.

150
00:12:33,700 --> 00:12:40,700
We then sum all of these terms up after we've multiplied them individually by their K constant.

151
00:12:40,700 --> 00:12:46,700
So integral gets multiplied by K I, derivative gets multiplied by K D.

152
00:12:46,700 --> 00:12:50,700
And as we saw earlier, error gets multiplied by K P or the proportional term.

153
00:12:50,700 --> 00:12:52,700
We also add this bias term.

154
00:12:52,700 --> 00:12:55,700
I would leave this at zero unless you absolutely need it.

155
00:12:55,700 --> 00:12:57,700
Try to solve everything else and get that working.

156
00:12:57,700 --> 00:13:00,700
If you still need that bias term, go ahead and add it.

157
00:13:00,700 --> 00:13:04,700
Finally, we save the error term for the next iteration.

158
00:13:04,700 --> 00:13:08,700
So we have that previous ready to go for our derivative calculation.

159
00:13:08,700 --> 00:13:12,700
Next, we're going to store these metrics in arrays so that we can plot them.

160
00:13:12,700 --> 00:13:18,700
And we're going to check if the encoder goes past one of our set guard angles.

161
00:13:18,700 --> 00:13:23,700
So if it's less than 160 or greater than what was it 200, I think.

162
00:13:23,700 --> 00:13:24,700
Yeah, 200.

163
00:13:24,700 --> 00:13:28,700
It's just going to stop the whole episode and break out of this loop.

164
00:13:28,700 --> 00:13:33,700
Finally, we're going to use matplotlib to plot a whole bunch of stuff for us.

165
00:13:33,700 --> 00:13:36,700
And we will take a look at that when we tune our controller.

166
00:13:36,700 --> 00:13:40,700
Before we tune, I'd like to show you where you can go to get this code.

167
00:13:40,700 --> 00:13:46,700
Head to github.com slash Sean email slash pendulum dash PID.

168
00:13:46,700 --> 00:13:49,700
All of the code that I'm showing you is in here.

169
00:13:49,700 --> 00:13:57,700
If you would like to try out your own version of this PID controller to control the inverted pendulum kit from ST micro electronics.

170
00:13:57,700 --> 00:14:01,700
Now, let's get to tuning our actual controller.

171
00:14:01,700 --> 00:14:11,700
As I mentioned earlier, the first thing we want to do is make sure that our stepper motor can recover from about plus or minus 10 degrees.

172
00:14:11,700 --> 00:14:18,700
So when I run this cell here, I'm going to offset this by about five or six degrees.

173
00:14:18,700 --> 00:14:21,700
See, oops, wrong way.

174
00:14:21,700 --> 00:14:22,700
Let's try that again.

175
00:14:22,700 --> 00:14:25,700
So it's moving at negative 90.

176
00:14:25,700 --> 00:14:26,700
So I'm going to hold it about here.

177
00:14:26,700 --> 00:14:28,700
Yes, it goes the other way.

178
00:14:28,700 --> 00:14:34,700
So that means the stepper motor is capable of correcting from that amount.

179
00:14:34,700 --> 00:14:35,700
Now let's get to tuning.

180
00:14:35,700 --> 00:14:41,700
I'm going to start off with one for the proportional and zero for the others.

181
00:14:41,700 --> 00:14:46,700
I'm just going to guess at one and let's see where that gets us.

182
00:14:46,700 --> 00:14:51,700
So I'm just going to hold this here and say go.

183
00:14:51,700 --> 00:14:52,700
Okay.

184
00:14:52,700 --> 00:14:57,700
So it looks like it's jittering a lot and then it's struggling to keep up at the.

185
00:14:57,700 --> 00:14:58,700
And there.

186
00:14:58,700 --> 00:15:00,700
Let's take a look at our output.

187
00:15:00,700 --> 00:15:09,700
Sure enough, there's a lot of oscillations, which means that our value for KP is a little too high.

188
00:15:09,700 --> 00:15:10,700
Let's try adjusting it.

189
00:15:10,700 --> 00:15:12,700
So we're going to go up here.

190
00:15:12,700 --> 00:15:18,700
Let's move it to 0.1 and let's try again.

191
00:15:18,700 --> 00:15:19,700
Okay.

192
00:15:19,700 --> 00:15:28,700
So there weren't as many oscillations there, but you could see it struggling to keep up.

193
00:15:28,700 --> 00:15:33,700
And if we look at our plot, sure enough, it never quite reaches our set point and it just

194
00:15:33,700 --> 00:15:35,700
kind of struggles to keep up.

195
00:15:35,700 --> 00:15:39,700
That means KP is too low.

196
00:15:39,700 --> 00:15:43,700
Let's try 0.5 about halfway in between.

197
00:15:43,700 --> 00:15:47,700
We'll run this again.

198
00:15:47,700 --> 00:15:48,700
Okay.

199
00:15:48,700 --> 00:15:49,700
Not bad.

200
00:15:49,700 --> 00:15:51,700
There's some oscillations.

201
00:15:51,700 --> 00:15:53,700
And in fact, I want to run this again.

202
00:15:53,700 --> 00:15:56,700
Be prepared to run some of these cells multiple times.

203
00:15:56,700 --> 00:15:57,700
Okay.

204
00:15:57,700 --> 00:16:00,700
Still some oscillations.

205
00:16:00,700 --> 00:16:04,700
It's oscillating around that 180 point.

206
00:16:04,700 --> 00:16:06,700
So it means it's a little too high.

207
00:16:06,700 --> 00:16:10,700
Still let's bring it down just a notch.

208
00:16:10,700 --> 00:16:12,700
We're going to take it to 0.3.

209
00:16:12,700 --> 00:16:13,700
Let's see what happens.

210
00:16:13,700 --> 00:16:18,700
Oh, that's really good.

211
00:16:18,700 --> 00:16:21,700
That keeps it for a while.

212
00:16:21,700 --> 00:16:26,700
Not much on the oscillations and it's just struggling to keep up.

213
00:16:26,700 --> 00:16:28,700
This is what we want.

214
00:16:28,700 --> 00:16:30,700
We want the integral term to make up this difference.

215
00:16:30,700 --> 00:16:36,700
This is that steady state offset between where the set point is and where it's trying

216
00:16:36,700 --> 00:16:39,700
to get to or as best as it can get.

217
00:16:39,700 --> 00:16:45,700
So we're going to keep it at 0.3 and see if we can get to KI, our integral term, to make

218
00:16:45,700 --> 00:16:47,700
up that difference.

219
00:16:47,700 --> 00:16:50,700
I'm going to guess at 0.1.

220
00:16:50,700 --> 00:16:52,700
It usually starts much lower than KP.

221
00:16:52,700 --> 00:16:55,700
So let's try that and see what happens.

222
00:16:55,700 --> 00:16:59,700
Oh, what just happened there?

223
00:16:59,700 --> 00:17:02,700
Let's try that again.

224
00:17:02,700 --> 00:17:07,700
Oh, it's oscillating badly and then it whips around.

225
00:17:07,700 --> 00:17:10,700
Let's go take a look at our plot.

226
00:17:10,700 --> 00:17:13,700
And here we go.

227
00:17:13,700 --> 00:17:14,700
Sure enough, it's unstable.

228
00:17:14,700 --> 00:17:19,700
You can see it bouncing back and forth and getting larger and larger before it loses control.

229
00:17:19,700 --> 00:17:20,700
That's unstable.

230
00:17:20,700 --> 00:17:27,700
That means that KI is definitely too large.

231
00:17:27,700 --> 00:17:29,700
Let's move exponentially here.

232
00:17:29,700 --> 00:17:39,700
So rather than say having this, let's go to 0.01 and see what happens.

233
00:17:39,700 --> 00:17:40,700
Oh wow.

234
00:17:40,700 --> 00:17:41,700
That's really good.

235
00:17:41,700 --> 00:17:42,700
Actually.

236
00:17:42,700 --> 00:17:46,700
That's almost where we want it.

237
00:17:46,700 --> 00:17:50,700
Still look like it's oscillating some.

238
00:17:50,700 --> 00:17:52,700
So let's stop that.

239
00:17:52,700 --> 00:17:54,700
Go take a look at our code.

240
00:17:54,700 --> 00:17:56,700
Yeah, there's still some oscillations here.

241
00:17:56,700 --> 00:18:00,700
I don't see it hitting up too high in the beginning and then it's oscillating a bit.

242
00:18:00,700 --> 00:18:04,700
Let's see if we can bring that down just a little bit.

243
00:18:04,700 --> 00:18:09,700
And in fact, let's go probably too low and see what happens.

244
00:18:09,700 --> 00:18:10,700
Start it here.

245
00:18:10,700 --> 00:18:20,700
That's not bad at all.

246
00:18:20,700 --> 00:18:23,700
Oh, it's losing it here.

247
00:18:23,700 --> 00:18:24,700
Okay.

248
00:18:24,700 --> 00:18:36,700
So something between 0.01, excuse me, 0.001 and 0.1 looks to be ideal.

249
00:18:36,700 --> 00:18:43,700
So let's say 0.005 for the sake of argument and try that.

250
00:18:43,700 --> 00:18:44,700
Oh, that's yes.

251
00:18:44,700 --> 00:18:46,700
This is what we're looking for.

252
00:18:46,700 --> 00:18:52,700
It's barely moving and it's keeping it upright and I can touch it and it corrects.

253
00:18:52,700 --> 00:18:54,700
And let's see if it recovers from that.

254
00:18:54,700 --> 00:18:58,700
Oh, I got to touch the other way before that gets too wound up around that axle.

255
00:18:58,700 --> 00:19:00,700
And then it goes the other way.

256
00:19:00,700 --> 00:19:04,700
So there's some larger level oscillations going on in here, but this should be okay.

257
00:19:04,700 --> 00:19:06,700
Let's scroll up.

258
00:19:06,700 --> 00:19:09,700
Yeah, 0.005 seems to be really good.

259
00:19:09,700 --> 00:19:21,700
Now we can take some time and really tune these, but I think with a KP of 0.3 and a KI of 0.005, gonna be good enough for now and our demonstration.

260
00:19:21,700 --> 00:19:25,700
As you can see, this PI controller pretty much does the job for us.

261
00:19:25,700 --> 00:19:32,700
We probably don't even need a derivative term in here, but let's just play with it and see what happens.

262
00:19:32,700 --> 00:19:35,700
We started with zero, which is a good place to start.

263
00:19:35,700 --> 00:19:39,700
I'm gonna guess 0.1 just to see what happens.

264
00:19:39,700 --> 00:19:43,700
Once again, this is usually lower than the KP term.

265
00:19:43,700 --> 00:19:44,700
So let's try this.

266
00:19:44,700 --> 00:19:50,700
This is actually not too bad.

267
00:19:50,700 --> 00:19:51,700
Okay.

268
00:19:51,700 --> 00:19:56,700
Let's take this down.

269
00:19:56,700 --> 00:20:11,700
And take a look at our graph here.

270
00:20:11,700 --> 00:20:13,700
It's looking pretty good.

271
00:20:13,700 --> 00:20:19,700
And just for argument, what if we take it to 0.5?

272
00:20:19,700 --> 00:20:20,700
What happens?

273
00:20:20,700 --> 00:20:25,700
This thing's still a beast.

274
00:20:25,700 --> 00:20:27,700
It's still going.

275
00:20:27,700 --> 00:20:30,700
Looks like it's a little unstable.

276
00:20:30,700 --> 00:20:37,700
We're getting some of those oscillations, which is probably fine for this.

277
00:20:37,700 --> 00:20:38,700
Okay.

278
00:20:38,700 --> 00:20:39,700
That's fine.

279
00:20:41,700 --> 00:20:47,700
And just so you can see what happens when we really crank this up, let's take it to five and really try to make this too high.

280
00:20:48,700 --> 00:20:49,700
Yeah, there we go.

281
00:20:49,700 --> 00:20:52,700
We're getting too many of the oscillations and it's pretty unstable.

282
00:20:52,700 --> 00:20:53,700
It can't control it.

283
00:20:53,700 --> 00:20:59,700
So that means we are suppressing KI and KP a little too much.

284
00:20:59,700 --> 00:21:03,700
And sure enough, you can see it with this encoder angle.

285
00:21:03,700 --> 00:21:04,700
It's struggling here.

286
00:21:04,700 --> 00:21:05,700
Okay.

287
00:21:05,700 --> 00:21:08,700
So we know we got to be less than five.

288
00:21:09,700 --> 00:21:15,700
And what happens if we take it really low like point zero zero one?

289
00:21:20,700 --> 00:21:21,700
Once again, it's pretty good.

290
00:21:21,700 --> 00:21:23,700
We can't really go too low with this.

291
00:21:23,700 --> 00:21:25,700
I'm going to stop it there.

292
00:21:25,700 --> 00:21:26,700
We can't really go too low.

293
00:21:26,700 --> 00:21:27,700
We can't really go too low.

294
00:21:27,700 --> 00:21:32,700
All we're trying to do is suppress this peak here or any of the peaks where it overshoots our set point.

295
00:21:33,700 --> 00:21:38,700
And in this particular system, an inverted pendulum, we don't mind a little bit of overshoot.

296
00:21:38,700 --> 00:21:41,700
Sometimes you can't have this overshoot.

297
00:21:41,700 --> 00:21:44,700
So you need KD to suppress that.

298
00:21:44,700 --> 00:21:54,700
But for our system, it looks like anything between like zero and one is probably fine for your KD.

299
00:21:54,700 --> 00:21:58,700
So I'm going to maybe make it a little higher.

300
00:21:58,700 --> 00:22:04,700
I'm going to make it a little higher as we saw with one is not too bad.

301
00:22:04,700 --> 00:22:05,700
Five was too high.

302
00:22:05,700 --> 00:22:07,700
Let's see what happens with one.

303
00:22:07,700 --> 00:22:12,700
Yeah, that's pretty good.

304
00:22:12,700 --> 00:22:14,700
There's still a little bit of jitter happening here.

305
00:22:14,700 --> 00:22:18,700
But once again, I don't think that's because of the KD term.

306
00:22:20,700 --> 00:22:21,700
Yeah, this is really good.

307
00:22:21,700 --> 00:22:22,700
It's moving back and forth.

308
00:22:22,700 --> 00:22:26,700
It's accomplishing its purpose of keeping the pendulum upright.

309
00:22:26,700 --> 00:22:35,700
And from that, I think we can safely assume we have a fully tuned PID controller for our inverted pendulum.

310
00:22:35,700 --> 00:22:42,700
If we go and look at our plots, you can see the encoder angle stayed pretty static the whole time.

311
00:22:42,700 --> 00:22:49,700
There's a little bit of an overshoot by about two and a half degrees on that first one, but it's really not bad.

312
00:22:49,700 --> 00:22:54,700
And you can see the stepper slowly oscillating back and forth.

313
00:22:54,700 --> 00:23:01,700
That's something that can be corrected with a dual or nested PID controller, but not something we're going to get into right now.

314
00:23:01,700 --> 00:23:06,700
Just so you see what happens, we're going to leave bias at zero.

315
00:23:06,700 --> 00:23:08,700
It actually works very well.

316
00:23:08,700 --> 00:23:11,700
Let's try 10 for the bias term and see what happens.

317
00:23:11,700 --> 00:23:12,700
So I'm going to.

318
00:23:12,700 --> 00:23:13,700
Yeah, exactly.

319
00:23:13,700 --> 00:23:14,700
Nothing.

320
00:23:14,700 --> 00:23:15,700
It's trying to overcorrect for something.

321
00:23:15,700 --> 00:23:17,700
That's not even a problem.

322
00:23:17,700 --> 00:23:20,700
We might be able to bring this down.

323
00:23:22,700 --> 00:23:23,700
Let's say five.

324
00:23:23,700 --> 00:23:24,700
Okay.

325
00:23:24,700 --> 00:23:25,700
It's still working.

326
00:23:25,700 --> 00:23:27,700
It's not particularly great.

327
00:23:27,700 --> 00:23:30,700
As you saw, there's no real need for this bias term in this.

328
00:23:30,700 --> 00:23:34,700
So I'm just going to leave this at zero.

329
00:23:34,700 --> 00:23:40,700
Let's put this bias term back at zero and we're going to call this pretty tuned for our needs.

330
00:23:40,700 --> 00:23:44,700
As you can see, it works pretty much most of the time.

331
00:23:44,700 --> 00:23:47,700
It will move back and forth a little bit.

332
00:23:47,700 --> 00:23:50,700
And that's something that could be corrected with additional control schemes.

333
00:23:50,700 --> 00:23:53,700
But for now, I'm going to call this good enough.

334
00:23:53,700 --> 00:23:57,700
I think we can say we have a fully tuned system.

335
00:23:57,700 --> 00:24:01,700
There's obviously some other tweaks, but let's go with that for now.

336
00:24:03,700 --> 00:24:12,700
I hope this helps you get started creating your own PID controllers and then tuning them for things like inverted pendulums or self-balancing robots.

337
00:24:12,700 --> 00:24:20,700
Obviously there are more complex control schemes out there, such as linear quadratic regulators and model predictive control.

338
00:24:20,700 --> 00:24:24,700
But PID controllers are a great introduction into control theory.

339
00:24:24,700 --> 00:24:27,700
If this is something you would like to tinker with.

340
00:24:27,700 --> 00:24:29,700
Good luck and happy hacking.

341
00:24:29,700 --> 00:24:31,700
Beep!

342
00:24:31,700 --> 00:24:32,700
Boop!

