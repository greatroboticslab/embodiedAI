wEevt2a4SKI
https://www.youtube.com/watch?v=wEevt2a4SKI
Unknown Category

[00:00:00.440 → 00:00:05.440] Hello everyone and welcome to another video. Today I'd like to talk about one
[00:00:05.440 → 00:00:09.440] of the most popular and powerful control design techniques around the linear
[00:00:09.440 → 00:00:14.320] quadratic regulator or LQR controller. We're gonna see that an LQR controller
[00:00:14.320 → 00:00:17.840] is effectively a full state feedback controller where the gain matrix K is
[00:00:17.840 → 00:00:21.240] computed in a very particular fashion. I'm gonna assume that you're a little
[00:00:21.240 → 00:00:23.960] bit familiar with full state feedback control but if you'd like a quick
[00:00:23.960 → 00:00:27.960] refresher please check out this previous video where we introduced full state
[00:00:27.960 → 00:00:32.960] feedback controllers. We're also going to see today that LQR controllers address
[00:00:32.960 → 00:00:36.660] some of the practical implementation issues we encountered when designing
[00:00:36.660 → 00:00:40.780] full state feedback controllers. So to get the most out of the discussion today I
[00:00:40.780 → 00:00:44.520] recommend that you also check out this other previous video where we discuss
[00:00:44.520 → 00:00:48.900] some of these implementation problems. Links to both of those videos are in the
[00:00:48.900 → 00:00:53.100] description below. So if all of this sounds like more fun than a clown on fire
[00:00:53.100 → 00:00:55.560] let's jump over to the whiteboard and get started.
[00:00:55.560 → 00:01:07.260] Alright so let's talk a little bit about the linear quadratic regulator or LQR
[00:01:07.260 → 00:01:13.660] controller. Right so like we said earlier the deal with an LQR controller is that
[00:01:13.660 → 00:01:18.180] let's assume that we've got a plant here it's a linear plant of our standard form
[00:01:18.180 → 00:01:23.240] here but the output like we said earlier is the entire state of the system. So if
[00:01:23.240 → 00:01:26.840] you have this scenario we said last time that pretty much the most powerful
[00:01:26.840 → 00:01:31.580] controller you can use here is a full state feedback controller like this.
[00:01:31.580 → 00:01:38.540] Right so here's your full state feedback controller. Right and the whole game plan
[00:01:38.540 → 00:01:43.480] at this point was to just to choose K. So last time I think we showed here that you
[00:01:43.480 → 00:01:52.360] can basically try to tailor how the full state feedback controller behaves by
[00:01:52.360 → 00:01:57.300] choosing desired closed-loop poles of that entire system. Right I think last time we
[00:01:57.300 → 00:02:02.260] said that you know if you had some some plant here with with certain open loop
[00:02:02.260 → 00:02:06.300] poles here right by the represented by these blue X's here right so these blue
[00:02:06.300 → 00:02:14.180] ones are open loop poles. In other words it was basically eigenvalues of just the A matrix.
[00:02:14.180 → 00:02:19.180] Right and what we said later was that okay I can just go over to MATLAB and I can say
[00:02:19.180 → 00:02:28.360] place A, B and some P desired. Right and this would give me a matrix K or it would give me the
[00:02:28.360 → 00:02:34.300] controller that would move the open loop eigenvalues in other words these blue X's to wherever I desire
[00:02:34.300 → 00:02:41.320] it to go here. Right where is this P desired. So we saw that by choosing locations of say
[00:02:41.320 → 00:02:45.580] say I want to move them you know something like this here right where these green
[00:02:45.580 → 00:02:56.800] ones are now my desired poles. These are my P desired. We saw that by changing these
[00:02:56.800 → 00:03:03.220] locations moving them further or closer or moving only certain poles right we could
[00:03:03.220 → 00:03:08.740] somehow mess with what value K was. But this was a little bit unsatisfying in the
[00:03:08.740 → 00:03:14.440] sense that there wasn't a real knob or a way to twist and and physically understand
[00:03:14.440 → 00:03:20.500] how the changes of these green X's affect the controller or affect the behavior of
[00:03:20.500 → 00:03:25.240] this overall system here. Right so that was the problem with full state feedback
[00:03:25.240 → 00:03:28.300] controller it was it was a little bit difficult to understand the relationship
[00:03:28.300 → 00:03:33.820] between P desired and the resulting K. Well this is exactly the problem that LQR is going
[00:03:33.820 → 00:03:39.520] to allow us to address here. What we're going to do here is try to pose this entire
[00:03:39.520 → 00:03:45.820] problem here in an optimization framework. So optimization is is one of the most powerful
[00:03:45.820 → 00:03:49.900] branches of mathematics. In fact I've heard a couple people say that you know it's
[00:03:49.900 → 00:03:53.740] it's it's probably the most important engineering topic here that that almost any
[00:03:53.740 → 00:03:57.820] problem in engineering can be posed as an optimization problem if you think about it
[00:03:57.820 → 00:04:01.900] long enough here. So what we should maybe do here is let's take a brief
[00:04:01.900 → 00:04:06.500] sidestep and talk a little bit about what is optimization and how can we maybe
[00:04:06.500 → 00:04:10.600] apply it to this scenario. So to set the stage for the concept of optimization
[00:04:10.600 → 00:04:13.980] let's talk about my daily commute. For those who don't know me I live in the
[00:04:13.980 → 00:04:17.980] Pacific Northwest specifically I live on Bainbridge Island which is about 10 miles
[00:04:17.980 → 00:04:21.820] west of Seattle Washington and I work at the University of Washington which is
[00:04:21.820 → 00:04:25.980] actually on the other side of this large body of water called Puget Sound. So the
[00:04:25.980 → 00:04:29.820] problem I'd like to consider now is how can I commute from my house to my work
[00:04:29.820 → 00:04:34.220] every single day. Why don't we brainstorm some possible solutions to this problem.
[00:04:34.220 → 00:04:38.860] Now luckily for me the state of Washington operates the largest ferry system in the
[00:04:38.860 → 00:04:43.260] United States so one option is I can just drive from my house down to the ferry
[00:04:43.260 → 00:04:48.700] terminal put my car on a ferry boat go across the Sound and when I get to Seattle
[00:04:48.700 → 00:04:53.420] just drive the rest of the way up to the University of Washington. So let's call
[00:04:53.420 → 00:04:58.060] this solution maybe Z1 where I drive from my house to the ferry catch the ferry
[00:04:58.060 → 00:05:03.100] and then drive to campus. What else could we do? Well if I don't want to drive maybe
[00:05:03.100 → 00:05:07.900] I'll catch a bus from my house to the ferry terminal walk onto the ferry boat and
[00:05:07.900 → 00:05:11.820] then when I get to Seattle just find some bus that happens to be going to the UW.
[00:05:11.820 → 00:05:19.740] So here that's Z2 here bus ferry bus. What about a third solution? Well if I want to get some
[00:05:19.740 → 00:05:24.300] exercise why don't I ride my bicycle to the ferry terminal and I can actually put my bike on the
[00:05:24.300 → 00:05:29.900] boat take it across the water and then when I get to Seattle ride the west of the way up to the
[00:05:29.900 → 00:05:37.660] University of Washington. Great so Z3 bike ferry bike. Why don't we think outside the box a little bit.
[00:05:37.660 → 00:05:44.460] I could maybe now run from my house to the nearest shoreline of Bainbridge Island hop in the water
[00:05:44.460 → 00:05:50.620] and swim five miles across the Sound here and then force Gump it to campus and arrive more tired
[00:05:50.620 → 00:05:58.860] than that creepy dwarf in Snow White. But you know what? Z4 where I run swim run is is actually a feasible solution.
[00:06:00.460 → 00:06:06.060] Alright let's just skip all of this hoo-ha and I'm just going to charter a helicopter to take me directly
[00:06:06.060 → 00:06:13.500] from my house and draw me off at my desk at the University of Washington every day. So Z5 is just charter a helicopter.
[00:06:14.140 → 00:06:22.540] You know what? This sounds good. So why don't we stop here? Let's call this entire set of all possible solutions the feasible set.
[00:06:22.860 → 00:06:29.100] The feasible set is basically every solution you would like to consider when solving an optimization problem.
[00:06:29.900 → 00:06:36.460] Okay so we saw that we had all of these potential solutions and we said we're going to call a
[00:06:36.460 → 00:06:42.460] collection or a set of all of these maybe big Z and we'll just put all of these solutions in here
[00:06:44.140 → 00:06:46.620] and this is what's referred to as the feasible set.
[00:06:46.620 → 00:06:54.940] So now that we have the feasible set put together the next thing we need is we need some way to measure
[00:06:54.940 → 00:07:01.260] the goodness of each one of these items in the feasible set. This is what's known as the concept of a cost function.
[00:07:03.260 → 00:07:07.820] So the idea with the cost function is that it is literally a function
[00:07:07.820 → 00:07:16.540] where you pass it in an element of the feasible set so it's one of these Z's here and all this
[00:07:16.540 → 00:07:23.420] thing's job is it's got one job right is it needs to evaluate how much does that item cost here okay.
[00:07:23.420 → 00:07:29.740] So what will come out of this is let's call this cost J of Z here right. So again this is typically
[00:07:29.740 → 00:07:38.620] we're going to use a notation J here so J of Z is going to be the cost function that measures
[00:07:40.620 → 00:07:51.820] how much solution Z costs right. So this could be in terms of dollars or any other abstract metric
[00:07:51.820 → 00:07:56.860] as long as it's a scalar value here right where you pass it in an action and an action you know it
[00:07:56.860 → 00:08:00.540] could be something complicated like all of these or it could be a vector it could be some item right
[00:08:00.540 → 00:08:05.100] it's some solution this thing gives you the number of dollars here right it gives you a single value
[00:08:05.100 → 00:08:11.900] which measures that right. So what we're going to see here is that the optimization problem involves
[00:08:11.900 → 00:08:19.180] finding a feasible solution here that will minimize the cost of a given problem here right. So tell you
[00:08:19.180 → 00:08:23.740] what let's consider a bunch of different cases here so let me erase some of this we can get a little bit
[00:08:23.740 → 00:08:29.580] of space so I'd like to consider a few different scenarios here so let's look at maybe case or
[00:08:29.580 → 00:08:36.540] scenario one here where I want to minimize time okay. So in this case what I'd like to do is I'm going to
[00:08:36.540 → 00:08:41.980] develop a cost function let's call it J1 of Z here right where what this cost function does is it just
[00:08:41.980 → 00:08:54.780] measures the time required for action Z right. So in this context the problem here or the optimization
[00:08:54.780 → 00:09:03.820] problem let's write it here as maybe P1 here right is I want to minimize J1 subject to the constraint
[00:09:03.820 → 00:09:08.620] here that I'm not going to consider all possible solutions I only want to consider solutions here
[00:09:08.620 → 00:09:14.780] that are in my feasible set here right only these five that we laid out here right. So if you look
[00:09:14.780 → 00:09:20.940] at this what the optimization problem says is I need to find the element in the feasible set which
[00:09:20.940 → 00:09:27.100] basically will yield the minimum time for my commute here right. So if you look at this here right we can
[00:09:27.100 → 00:09:31.580] we can iteratively by brute force just go through every single one of these and evaluate how long they
[00:09:31.580 → 00:09:37.340] each take um and and the winner is going to be Z5 here right you can pretty much see that out right off the bat
[00:09:37.340 → 00:09:42.060] that this is going to get me from my house to campus in the minimal amount of time here. So in this
[00:09:42.060 → 00:09:53.260] scenario here right the thing that is optimal here is Z5 is optimal right. Okay well um how about let's
[00:09:53.260 → 00:09:58.700] consider another case how about case two maybe let's underline these so we can keep them uh apart case two
[00:09:58.700 → 00:10:05.180] here how about how about let's minimize money right so instead of time being important let's say I'm super
[00:10:05.180 → 00:10:11.340] cheap and frugal and I care about money so I need to develop a second cost function J2 of Z. This cost
[00:10:11.340 → 00:10:22.620] function's only job in life here is to measure literally the cost of action Z right. So how many
[00:10:22.620 → 00:10:27.820] dollars does each one of these things cost? So I can form an entirely new optimization problem let's call
[00:10:27.820 → 00:10:37.020] it P2 right where I now same thing I want to minimize uh this other cost function J2 here again I'm only
[00:10:37.020 → 00:10:42.220] going to look at solutions in my feasible set here right. So I go through each one of these and I ask how
[00:10:42.220 → 00:10:47.740] much does this cost here well it cost me some gas and then to catch the ferry I actually have to pay to take
[00:10:47.740 → 00:10:55.660] my car across then it costs me some gas again. Oh here Z2 this is actually a little cheaper here because I don't have to pay to take my car
[00:10:55.660 → 00:11:01.820] across the ferry I can just walk on which is actually um much cheaper uh oh this is this is also kind of
[00:11:01.820 → 00:11:08.860] cheap here but oh hey check this out Z4 this doesn't cost me a dime here right nobody's I can run for free
[00:11:08.860 → 00:11:13.580] to the shoreline it doesn't cost me anything to swim across well it doesn't cost me any money maybe let's
[00:11:13.580 → 00:11:17.820] put it that way it might cost me other things but it doesn't cost me any money to get across Puget Sound
[00:11:17.820 → 00:11:23.980] and I can run and oh crud Z4 the helicopter is definitely going to cost me a boatload of cash here so
[00:11:23.980 → 00:11:30.140] you know what in this scenario here with this cost function the optimal thing to do is actually Z4
[00:11:30.140 → 00:11:36.780] right huh so this is really interesting here in the sense that this same optimization problem we can
[00:11:36.780 → 00:11:42.300] change the solution by picking the cost function appropriately so tell you what let's go ahead and
[00:11:42.300 → 00:11:48.780] look let's make another variation on this how about case three here let's try to look at a minimizing a
[00:11:48.780 → 00:12:00.860] time and money trade-off okay so in this case why don't I make a cost function let's call it j3
[00:12:00.860 → 00:12:08.860] which is actually a combination of these two here so let's have j1 here remember j1 returned the time
[00:12:08.860 → 00:12:15.820] required and I'm going to add that to j2 which measured the cost here and what I could do here is
[00:12:15.820 → 00:12:22.460] I could put some scalar weights in front of these here which would allow me to sort of trade off
[00:12:22.460 → 00:12:28.780] between how much do I value time versus how much do I value money here right so in this case q and r
[00:12:29.420 → 00:12:37.980] are scalar let's call them weights right that we can use to tune the optimization problem here right
[00:12:37.980 → 00:12:44.540] so you know if you if you look at this you can basically see here that depending on on q or r you
[00:12:44.540 → 00:12:49.900] can say do I care more about time or do I care more about money so just to kind of write this
[00:12:49.900 → 00:12:53.100] down right if you look at this here well again maybe we should write down the problem here right
[00:12:53.100 → 00:13:00.140] so the problem is the same thing so p3 is now I just want to minimize this new cost function j3 of z
[00:13:00.700 → 00:13:09.020] such that subject to z is in our feasible set big z okay so depending on what values of q and r we choose
[00:13:09.020 → 00:13:14.380] you probably get different values here right so in general right you can see here that a large q
[00:13:15.020 → 00:13:22.300] relative to r right what is that going to do here right that's basically saying that you're reverting
[00:13:22.300 → 00:13:31.020] to a a minimum time problem right because if q is big then if the time is big this b the the whole entire
[00:13:31.020 → 00:13:38.380] cost function becomes big here so you really want to um uh choose solutions that minimize time here so
[00:13:38.380 → 00:13:44.300] if you do this here this is basically saying you uh whoops i should be relative to r right you're
[00:13:44.300 → 00:13:50.060] you're super rich and your time is more important than your money here right so if you do this um you
[00:13:50.060 → 00:13:58.540] say what we're basically doing here is this this this kind of reverts uh to a min time problem
[00:13:59.660 → 00:14:04.700] right basically reverts to this case here right so we see that all right in this case you end up again
[00:14:04.700 → 00:14:11.340] back with with our z5 um solution of just getting the helicopter right alternatively if you have a
[00:14:11.340 → 00:14:21.980] small q relative to r right this is now saying that uh no actually uh you're super frugal right you don't
[00:14:21.980 → 00:14:30.860] have any money so any expenditure of cash is is very very bad here right so that means that r is sorry
[00:14:30.860 → 00:14:36.700] where was i put yeah r is larger than q here right so what this does is what this reverts to a minimum
[00:14:38.060 → 00:14:45.740] money problem here right so here the solution comes back to being z4 here right which makes sense
[00:14:45.740 → 00:14:49.420] now where it gets really interesting here is what if you have a trade-off
[00:14:51.340 → 00:15:00.220] between q and r right in this case this is a new scenario right where now it depends it depends how
[00:15:00.220 → 00:15:06.540] much do you value time versus how much do you value money so in this case we have we have potential
[00:15:06.540 → 00:15:10.300] solutions i don't know which one is going to be optimal again it depends on what values of r
[00:15:10.300 → 00:15:18.940] but now you've got a z1 z2 or maybe z3 as being reasonable solutions here all right let's explore
[00:15:18.940 → 00:15:25.420] this a little bit further here let's think of maybe um a case four so let's do this right here unfortunately
[00:15:25.420 → 00:15:31.900] i didn't manage the board space extremely well here but let's look at case four case four is basically
[00:15:31.900 → 00:15:35.900] i'd like to look at case three again right this interesting situation where we're trading off time
[00:15:35.900 → 00:15:44.700] and money but i'd like to add what are called constraints okay so what constraints allow us to do
[00:15:44.700 → 00:15:51.980] here is further tailor the solution to this problem here by eliminating values in the feasible set so
[00:15:51.980 → 00:15:57.340] what this does here is again let's restate our problem here so i'm gonna i'm gonna call this p4
[00:15:57.340 → 00:16:03.100] now here but again it's it's the same cost function as case three right so i want to minimize uh
[00:16:05.100 → 00:16:12.700] j3 right this was our trade-off cost function here subject to elements in the feasible set here
[00:16:12.700 → 00:16:19.180] and i'm going to tack on some additional constraints here as something like what if i say i want to make
[00:16:19.180 → 00:16:25.820] some kind of requirement here that i need to get 30 minutes of exercise during my commute or more here
[00:16:25.820 → 00:16:32.620] so what i'm going to do is i'm going to make up a function let's call it f1 here right where f1's job
[00:16:32.620 → 00:16:38.060] here is that you put in one an element out of your out of your feasible set here and what this measures
[00:16:38.060 → 00:16:50.940] here is it measures the exercise time uh associated with action z right so the optimization problem
[00:16:50.940 → 00:16:57.340] becomes what we saw earlier but as well i'm going to specify a constraint like i need f1 of z to be
[00:16:57.340 → 00:17:02.460] greater than or equal to 30 minutes here so this is basically saying that on my commute i also want to
[00:17:02.460 → 00:17:09.180] make sure that i get 30 minutes of uh exercise what this does by specifying this additional constraint
[00:17:09.180 → 00:17:16.220] here is we see that it starts making some of these elements um in this original feasible set infeasible
[00:17:16.220 → 00:17:20.860] so for example if we look at all of these here let's let's just walk down these one at a time right
[00:17:20.860 → 00:17:28.220] how much exercise am i going to get out of uh each one of these so z1 here right z1 if i pass this
[00:17:28.220 → 00:17:33.740] through my f function it's going to look and say hey you spent zero minutes exercising because you're
[00:17:33.740 → 00:17:38.540] just walking in the uh driving in the car then you sit on your bum on the ferry doing nothing and then
[00:17:38.540 → 00:17:44.220] you drive some more so this actually does like nothing so this is now not going to be allowed any
[00:17:44.220 → 00:17:50.700] longer here so z1 is no longer a feasible solution same thing with z2 you're just sitting on the bus and
[00:17:50.700 → 00:17:55.980] sitting on the ferry so f1 this function here or this constraint that we cooked up is going to say no
[00:17:55.980 → 00:18:02.380] that's not allowed any longer okay z3 this is uh yeah actually this is still allowed because you're
[00:18:02.380 → 00:18:08.140] going to get a lot of exercise biking here on either end so this is allowed oh man z4 is definitely
[00:18:08.140 → 00:18:12.700] allowed right you're probably going to get more exercise than you want here and then the helicopter
[00:18:12.700 → 00:18:18.940] becomes infeasible because you don't get any exercise on this helicopter here right so suddenly
[00:18:18.940 → 00:18:24.380] this problem here now gets a little bit simpler because the feasible set shrunk so there's only two
[00:18:24.380 → 00:18:32.220] solutions here you can either bike or uh or or run and swim here right and usually for most values of
[00:18:32.220 → 00:18:37.580] r and q uh q and r right you're going to see that that z4 solution that's going to take that's going to
[00:18:37.580 → 00:18:44.380] take hours and hours and hours and hours so usually this this term here the the the the cost function
[00:18:44.380 → 00:18:50.940] that's measuring time is going to make that uh z4 solution really unattractive so in this case here
[00:18:50.940 → 00:18:58.460] what's probably going to happen here is we're going to end up with z3 is optimal right so this is
[00:18:58.460 → 00:19:04.220] really fascinating in the sense that depending on how you tailor your optimization problem right the
[00:19:04.220 → 00:19:10.060] solutions change here what is considered optimal changes here right so this is actually really
[00:19:10.060 → 00:19:16.620] interesting and now the question would be how can we apply this optimization framework to designing a
[00:19:16.620 → 00:19:23.340] control system for a linear dynamic system so um let me erase the board and we'll we'll jump into that
[00:19:23.340 → 00:19:29.740] next okay now that we've got that basic understanding of general optimization let's think about how we can
[00:19:29.740 → 00:19:35.980] set up the optimization problem for designing a linear quadratic regulator here so let's talk real quick about
[00:19:35.980 → 00:19:39.420] setting up the optimization problem
[00:19:39.420 → 00:19:49.420] so i always think it's easiest to think about a concrete scenario so you know what if we had
[00:19:49.420 → 00:19:55.500] something like like uh like a satellite here so i'm going to try to draw a satellite here i'm obviously
[00:19:55.500 → 00:20:00.860] not a very good artist i think those of you who have seen some of my other videos understand that
[00:20:00.860 → 00:20:06.620] um but i'll just make some little cartoon here for a satellite here and what we'd like to think about
[00:20:06.620 → 00:20:12.940] here is this satellite might have uh multiple states here right so the state vector for this
[00:20:12.940 → 00:20:21.180] satellite might be something like um the orientation right there might be states for the for the oiler
[00:20:21.180 → 00:20:27.180] angles there might be states for like the position um all these other things right we will just stack
[00:20:27.180 → 00:20:33.340] all these up in the state vector and at the same time this aircraft this satellite might have multiple
[00:20:33.340 → 00:20:39.020] different controls right it might have like a primary thruster here it might have smaller positioning
[00:20:39.020 → 00:20:45.180] thrusters or or momentum wheels or things like that here so we might want to also say that this thing
[00:20:45.180 → 00:20:53.740] has multiple controls here right so this would be like the like the main thruster um you know electric thrusters
[00:20:56.700 → 00:20:57.820] momentum wheels
[00:20:57.820 → 00:20:59.980] controls
[00:21:01.020 → 00:21:06.220] etc etc etc etc right all we're getting at is that this here is a dynamic system which has
[00:21:06.220 → 00:21:12.860] multiple states and multiple controls simultaneously let's go ahead and assume that this is a linear system
[00:21:12.860 → 00:21:16.860] governed by dynamics of x dot is equal to ax
[00:21:18.700 → 00:21:24.540] plus bu right our normal state space representation of my dynamic system basically saying that
[00:21:25.100 → 00:21:29.420] the state and the control they're not free to be anything they want right there's a relationship
[00:21:29.420 → 00:21:34.380] between how the states and the controls interact and they interact through this dynamic equation here
[00:21:34.380 → 00:21:41.580] right so within this context here what we want to do here is let's set up an optimization problem here so
[00:21:41.580 → 00:21:45.100] the optimization problem here is let's go ahead and consider a cost function
[00:21:47.900 → 00:21:53.500] let's just call this thing j like we did earlier here and we're going to propose this cost function here
[00:21:53.500 → 00:21:59.020] it's going to be the integral from time zero to infinity of x transpose
[00:22:00.300 → 00:22:04.060] times some matrix qx plus u
[00:22:06.060 → 00:22:16.140] transpose some matrix r u dt okay so here's our cost function here in this case we see that x obviously
[00:22:16.140 → 00:22:26.540] is your n by one state vector right u is our usual m by one control vector
[00:22:28.940 → 00:22:33.660] and here q is a n by n symmetric
[00:22:36.860 → 00:22:41.420] positive semi-definite and we'll talk about the
[00:22:41.420 → 00:22:47.100] uh definition of that here uh matrix here
[00:22:47.100 → 00:22:54.300] uh matrix here sometimes you'll see this written as q greater than zero or sometimes you might see q
[00:22:54.300 → 00:23:03.660] like this kind of scripty greater than zero here um again this is a notation for this matrix is positive
[00:23:03.660 → 00:23:15.340] uh uh yes positive semi-definite here and finally r is a m by m symmetric positive definite
[00:23:17.660 → 00:23:25.180] matrix so again sometimes written as q oh i'm sorry sorry come back to the sorry come back to the q
[00:23:25.180 → 00:23:30.460] here positive semi-definite means greater than or equal to sometimes it's written like this to contrast it
[00:23:30.460 → 00:23:35.420] with positive definite which means that it well we'll get to that in a second again you might see
[00:23:35.420 → 00:23:39.900] this written as something strictly greater than or again this this scripty
[00:23:41.900 → 00:23:48.860] greater than symbol here right okay um maybe now might be a good idea to to discuss what is the
[00:23:48.860 → 00:23:54.940] definition of positive definite and positive semi-definite let's come back to this and uh let's delete our picture
[00:23:54.940 → 00:23:59.820] here i think we understand the scenario that i like to keep in the back of your head so just keep in
[00:23:59.820 → 00:24:03.900] keep in your head that you know the state vector here let's let's think about this as being a state
[00:24:03.900 → 00:24:08.060] vector for the satellite and the control vector being as the control vector for this particular
[00:24:08.060 → 00:24:14.940] satellite here so the the concept here with uh positive semi-definite here so maybe let's write
[00:24:14.940 → 00:24:26.460] that down so positive semi-definite means that this matrix q if you took it and multiplied it by some vector
[00:24:26.460 → 00:24:33.580] x transpose and then multiplied it again by x this is a skate going to be a scalar number here if you if
[00:24:33.580 → 00:24:39.420] you do the dimensions here right this is n by one by an multiplied by an n by n multiplied by an n by one
[00:24:39.420 → 00:24:44.380] and excuse me when by the time you transpose this thing this becomes one by n right so you can see the
[00:24:44.380 → 00:24:53.900] whole thing ends up as a one by one scalar here right this scalar quantity is always greater than or equal
[00:24:53.900 → 00:25:01.100] to zero to zero for all possible x values here right so that's the definition of positive semi-definite
[00:25:01.100 → 00:25:07.500] is that this matrix is positive semi-definite if when you compute this weird quantity x transpose qx
[00:25:07.500 → 00:25:14.140] it is strict it is greater than or equal to zero for any value of x this vector right this this vector
[00:25:14.140 → 00:25:19.100] could have positive negative zeros whatever it doesn't matter by the time you run it through and compute
[00:25:19.100 → 00:25:24.540] this you get something that is strict is greater than or equal to zero all the time here right
[00:25:25.820 → 00:25:38.700] similarly the definition of positive definite right is that again you have this this uh this this matrix
[00:25:38.700 → 00:25:44.220] r here which we claim is positive definite the definition is that if you take some vector u maybe
[00:25:44.220 → 00:25:52.540] in this case transpose times u this is strictly greater than zero for all u right so again you can
[00:25:52.540 → 00:25:57.500] work out the dimensions and you see that this is a scalar number here so here's the definition of positive
[00:25:57.500 → 00:26:03.580] semi-definite and positive definite and what's interesting about that is that is exactly what are the terms of
[00:26:03.580 → 00:26:09.180] the integrand of the cost function here right so you see that the re the way that this cost function is
[00:26:09.180 → 00:26:18.460] set up here is that the integrand is always positive or uh or well actually yeah it's it's positive right
[00:26:18.460 → 00:26:24.700] uh for any x u combinations here right so you can never get a negative integrand the integrand is
[00:26:24.700 → 00:26:29.740] always positive so let's let's keep that in the back of our head as we uh continue discussing this okay
[00:26:30.300 → 00:26:35.420] all right so now that we understand positive definite and positive semi definite we have a we have a rough
[00:26:35.420 → 00:26:41.980] kind of um feeling for what this this cost function does right you can kind of see here that again the
[00:26:41.980 → 00:26:48.860] integrand is always positive and this q and this r those are sort of these weighting matrices or weighting
[00:26:48.860 → 00:26:53.260] values that we saw earlier when we were looking at our brief introduction to optimization right
[00:26:53.260 → 00:26:59.820] we earlier the q and the r were somehow to trade off between time versus money here right in this case
[00:26:59.820 → 00:27:06.940] we see that q and r trade off between states here non-zero states or non-zero controls we're going to
[00:27:06.940 → 00:27:11.340] take a closer look at that in a second but i wanted to plant that seed in your head right now let's start
[00:27:11.340 → 00:27:19.340] thinking about q and r as weights uh to to determine how much we value states versus how much we value
[00:27:19.340 → 00:27:27.580] controls here right okay so now that we have the the the cost function down the overall problem now in this
[00:27:27.580 → 00:27:31.260] scenario here is actually tell you maybe let's let's do it over here so we can keep talking about the
[00:27:31.260 → 00:27:36.540] the problem here so here's the cost function so the optimization problem let's write this again as our
[00:27:36.540 → 00:27:45.980] script dp symbol here right is all i want to do now here is i want to minimize this cost function j here right
[00:27:48.140 → 00:27:57.260] but um uh the controls i want to use here right there's m controls here so u is
[00:27:57.260 → 00:28:06.540] is a real valued uh m valued uh vector here right but we're not this is not unconstrained here there's
[00:28:06.540 → 00:28:13.580] a certain constraint right such that the single constraint that we want to consider here is that
[00:28:13.580 → 00:28:24.140] again x and u are not free to be anything you want here right it's x dot is equal to ax plus bu
[00:28:24.140 → 00:28:31.660] right so here is my optimization problem that i would like to solve here right and if we think
[00:28:31.660 → 00:28:36.780] about this long enough what it's basically saying here is that you want to take this cost function
[00:28:36.780 → 00:28:43.980] here and i want to find some control signal or some control law that is going to make this cost function
[00:28:43.980 → 00:28:49.980] minimal so so first of all let's stop let's think about that first ignore the constraint maybe for now
[00:28:49.980 → 00:28:56.460] right how would you make this minimal here so for example assume that your satellite had some non-zero
[00:28:56.460 → 00:29:02.140] initial condition like x of zero was not equal to zero in other words your satellite was cocked over
[00:29:02.140 → 00:29:08.460] at some weird orientation and some weird position not zero right something that you that you didn't want
[00:29:08.460 → 00:29:18.140] here right so this term is non-zero at time zero right now if the satellite stayed there right if you
[00:29:18.140 → 00:29:23.980] left it here like let's draw a quick picture maybe of just one of the states like x1 right
[00:29:24.620 → 00:29:31.020] if it's here's our our initial condition right so so maybe it is banked over at 45 degrees away from
[00:29:31.020 → 00:29:38.060] where you wanted to right if you left it here right and did nothing right what does this cost function
[00:29:38.060 → 00:29:44.620] look like here you can kind of see it already it's there's gonna be a square there's gonna be an x1 squared term here
[00:29:44.620 → 00:29:49.980] multiply by this q let's assume that q is like all ones or something like that effectively what
[00:29:49.980 → 00:29:55.340] the cost function there is measuring is it's sort of measuring the integral of this right of course
[00:29:55.340 → 00:30:00.060] it's going to be squared it might be skewed or weighted by that q value we're going to see that in
[00:30:00.060 → 00:30:05.740] a second but long story short here if this stayed here at a constant value this cost function is going
[00:30:05.740 → 00:30:11.420] to blow up to to infinity here right because it's it's the integral from time zero to infinity here right
[00:30:11.420 → 00:30:18.060] um so you can't have this here right this is obviously not the optimal thing to do here you
[00:30:18.060 → 00:30:24.940] can't leave the satellite cocked over at 45 degrees because that yields a cost function value of infinity
[00:30:24.940 → 00:30:31.980] here right so that's obviously not a good thing to do so instead what is better here right is we should
[00:30:31.980 → 00:30:39.260] try to bring the system back to the origin here right and now the cost here is finite right it's just
[00:30:39.260 → 00:30:44.700] sort of this area under the curve is is the the cost value so this is a better solution than letting
[00:30:44.700 → 00:30:50.460] it stay at 45 degrees so what that means is your satellite is cocked over 45 degrees what we're gonna
[00:30:50.460 → 00:30:58.940] do here is is maybe bring it back to zero that yields a better result here right however the the other flip
[00:30:58.940 → 00:31:04.380] side of that story here is how are you gonna bring the satellite back to zero here well you're probably
[00:31:04.380 → 00:31:09.020] gonna have to fire some thrusters right some positioning thrusters you're gonna have to expend
[00:31:09.020 → 00:31:15.420] some amount of control in order to do that here right so if we plot again i'm this is a real rough
[00:31:15.420 → 00:31:19.420] shooting from the hip description of this we're gonna look at it in a more formal fashion in a second
[00:31:19.420 → 00:31:24.700] here but let's just plot one of these controls like maybe u of t this is like one of the positioning
[00:31:24.700 → 00:31:30.460] thrusters or something like that right well what you're gonna probably have to do is is if you want to
[00:31:30.460 → 00:31:35.500] bring the satellite back to zero you're probably gonna have to spend some control authority to do that
[00:31:35.500 → 00:31:40.220] and then again you're probably gonna have to let this come back to zero here right so you're gonna
[00:31:40.220 → 00:31:44.780] actuate the controller and like you're gonna bring it back to zero then you're gonna stop actuating the
[00:31:44.780 → 00:31:52.780] controller right so the overall cost function you can kind of see it's sort of a combination of both
[00:31:52.780 → 00:31:59.500] how long are you away from zero in the states and how much non-zero control authority did you actually
[00:31:59.500 → 00:32:06.540] have to expend in order to get that here right so what you can see from this discussion here is what
[00:32:06.540 → 00:32:13.500] q and r do or q and r are these knobs that allow you to determine how much do you care about the state
[00:32:13.500 → 00:32:19.580] being zero versus how much do you care about the control not being zero here so let's talk about that
[00:32:19.580 → 00:32:30.460] real quick in general right what you end up seeing here is that um you know roughly speaking if q is is
[00:32:30.460 → 00:32:40.300] big compared to r so maybe we should write that down here right so if q is bigger let's put this in quotes
[00:32:40.300 → 00:32:48.060] here than r the reason it's in quotes here is because if you can you can see q and r they're two matrices
[00:32:48.060 → 00:32:52.940] they're square and they're symmetric but they're not even like the same size so how do you really
[00:32:52.940 → 00:32:56.620] say one is bigger than the other here well we're going to get to that in a little bit but you can
[00:32:56.620 → 00:33:02.620] kind of you can see the gist here right if q is bigger than r here what are you basically saying
[00:33:03.260 → 00:33:11.500] you're basically saying here that i really care that x is not equal to zero because if so this this
[00:33:11.500 → 00:33:17.820] term dominates here right so in this situation let me do this in another color here right this term dominates
[00:33:18.060 → 00:33:25.660] so really all you're saying here is the important thing in this case here is that if the states are
[00:33:25.660 → 00:33:32.140] not equal to zero you end up with a huge cost here right who cares about what the control is it's really
[00:33:32.140 → 00:33:38.220] the states that matter and drive this cost function here so in this scenario what do we end up with
[00:33:38.220 → 00:33:44.940] this is basically saying here the optimal thing to do here is do what you have to but make sure those
[00:33:44.940 → 00:33:51.420] states go back to zero as soon as possible here right so this is typically going to yield something
[00:33:51.420 → 00:34:03.180] like um you would have a fast regulation of x to zero right and in order to do that you're going to end
[00:34:03.180 → 00:34:12.460] up with u is large right so this is sort of the scenario where you're saying control is cheap i don't care
[00:34:12.460 → 00:34:17.580] what you do just make sure the state goes back to zero really really quickly here right let's flip that
[00:34:17.580 → 00:34:25.740] and and and and and compare with you know what happens if um r uh is bigger
[00:34:28.300 → 00:34:38.700] than q right so in that case we have the exact opposite scenario here right where now it's this term
[00:34:38.700 → 00:34:45.900] that dominates in the cost function right so the optimal thing to do here is make sure that you
[00:34:45.900 → 00:34:52.620] stays as small as possible here because if if you even flinches up for or flares up if you actuate one
[00:34:52.620 → 00:34:57.420] control just a teeny little bit this term in your cost function is going to blow up and you're going to
[00:34:57.420 → 00:35:03.660] end up with a huge cost here right so the intent under this situation the right thing to do here is
[00:35:03.660 → 00:35:11.020] use control very very very sparingly here right and who cares what the state ends up doing in this
[00:35:11.020 → 00:35:17.180] scenario if it stays if the satellite stays cocked over and just takes you know hundreds of seconds to
[00:35:17.180 → 00:35:23.900] come back to to the origin that's fine as long as you don't fire those thrusters because the propellant
[00:35:23.900 → 00:35:29.500] you're expending is is extremely valuable here right so the behavior that typically ends up happening here
[00:35:29.500 → 00:35:37.820] is you know if you have r bigger than q here you have very slow uh regulation of x to the origin here
[00:35:37.820 → 00:35:47.500] right and u is small right so this is really interesting here so you end up with this the the
[00:35:47.500 → 00:35:53.180] the first case here this is like an aggressive controller right and down here you have a conservative
[00:35:53.180 → 00:36:00.300] controller so we see that q and r are these knobs that are going to allow us to to to tweak the
[00:36:00.300 → 00:36:05.740] states and the controls or or or excuse me tweak the controller depending on how much we care about
[00:36:05.740 → 00:36:10.540] the states and controls let's look at a very concrete example the cost function and i think we'll be able
[00:36:10.540 → 00:36:18.060] to see that here so for example here right let's look at a a two state two control system
[00:36:18.060 → 00:36:25.660] right so what if your satellite here that we're looking at it only had two states like uh like we
[00:36:25.660 → 00:36:32.220] were looking uh at just the um sorry let me just write this down so i can i can talk at the same time
[00:36:32.220 → 00:36:38.220] here right there's only two states like maybe i only care about the pitch angle and the pitch rate or
[00:36:38.220 → 00:36:44.780] something like that of it and then i only have two controls here like i have a electric thruster and a
[00:36:44.780 → 00:36:53.180] single momentum wheel or something like that right okay and now let's let's pick values of this q and
[00:36:53.180 → 00:36:58.140] these r matrices here so in other words let's first start with something really really simple let's make
[00:36:58.140 → 00:37:04.940] the q matrix just diagonal and we'll have a q11 and a q1 uh sorry q22 let's make zeros over here
[00:37:04.940 → 00:37:14.300] similarly for the r matrix right r is just going to be an r1100 r22 right okay so these are these are
[00:37:14.300 → 00:37:19.740] these are symmetric and as long as all of these these entries are positive we'll see that these
[00:37:19.740 → 00:37:26.140] yield a positive semi-definite and a positive uh definite matrix here right so if this is the case
[00:37:26.140 → 00:37:30.300] let's compute this cost function here or more importantly maybe let's just compute the integrand
[00:37:30.300 → 00:37:36.060] of the cost function here um maybe let's see what can we do yeah yeah let's let's erase this i think we
[00:37:36.060 → 00:37:42.860] got the got the picture here okay so now what i want to do here is our is compute the integrand here
[00:37:42.860 → 00:37:54.220] right of x transpose q x plus u transpose ru right so run to mathematica and plug all this in here and
[00:37:54.220 → 00:37:59.980] what you'll end up seeing here is that this integrand looks like it's it's pretty simple it's a q11x1
[00:38:00.540 → 00:38:11.180] squared plus a q22x2 squared maybe let's put the squared like this sorry um plus an r11u1
[00:38:11.820 → 00:38:21.740] squared plus an r22u2 squared here right so here i think you can very clearly explicitly see
[00:38:21.740 → 00:38:30.620] what do these q11q2 and 22 and r11 and r22 entries uh physically mean right if you look at this right
[00:38:30.620 → 00:38:44.540] we see that q11q1 is sort of the uh the weight or the the penalty effectively on a non-zero x1 right
[00:38:44.540 → 00:38:52.940] because it shows up right here right so if x1 is not zero right um if it's positive or negative by the
[00:38:52.940 → 00:38:58.860] time you square it this term is going to be positive here right so as long as the magnitude is not zero this
[00:38:58.860 → 00:39:05.980] square term is something uh positive and q11 is now this this multiplicative factor here showing you
[00:39:05.980 → 00:39:12.300] how much does it matter that x1 is not zero here right it will either exacerbate that in terms of
[00:39:12.300 → 00:39:17.260] the cost or it would attenuate it depending on on this value here right and similarly let's just go
[00:39:17.260 → 00:39:22.620] through all of these just to be very very explicit so q22 right this is the weight or the penalty on a
[00:39:22.620 → 00:39:31.340] non-zero x2 right so we very clearly see that the q matrix by choosing the entries appropriately you can
[00:39:31.340 → 00:39:36.540] now say which state do i really care about being non-zero right i can either say that i really care
[00:39:36.540 → 00:39:44.700] about x1 being non-zero or i care about x2 being not zero similarly the r11 term right you see it right
[00:39:44.700 → 00:39:53.740] here right this is the weight or the penalty on a non-zero u1 of t right and similarly r22 is just the
[00:39:53.740 → 00:40:01.900] weight or the penalty on a non-zero u2 of t right so r11 is basically it's it's actually telling you
[00:40:01.900 → 00:40:10.540] pretty much exactly how expensive is it to fire or to to utilize control number one right yeah this was
[00:40:10.540 → 00:40:13.900] like maybe your your electric thruster maybe it doesn't cost you anything at all right because
[00:40:13.900 → 00:40:19.100] that's the whole deal with electric thrusters is that electric thrusters are are are cheap um they
[00:40:19.100 → 00:40:23.980] are long lasting they're reliable here so so if you want to model that fact here in your control design
[00:40:23.980 → 00:40:30.780] you can maybe pick a pick a small r11 right because if r11 is small it's basically saying i don't care
[00:40:30.780 → 00:40:35.260] what you're doing with this controller this controller is super duper cheap because even though if this
[00:40:35.260 → 00:40:42.380] control is is is large by the time i multiply by a small r11 this doesn't contribute to the overall
[00:40:42.380 → 00:40:49.660] cost function much right and in the same fashion you see that r22 is is the is the cost of actuating
[00:40:49.660 → 00:40:56.940] controller number two here right so that's pretty awesome this i think allows us to set up the entire
[00:40:56.940 → 00:41:03.500] optimization problem here right now the thing that's interesting here is now if we start coming back and
[00:41:03.500 → 00:41:08.940] thinking about um the the constraint here right this is the interesting part we i think we understand
[00:41:08.940 → 00:41:14.620] the cost function at this point right we understand how to tailor or to to tune this cost function using
[00:41:14.620 → 00:41:20.700] this q and this r matrix here right but the thing that we have to do now is we have to solve this overall
[00:41:20.700 → 00:41:27.420] problem now here subject to the linear dynamics of this system here right so that's where it gets
[00:41:27.420 → 00:41:32.940] interesting so why don't i pause the video i'll erase the board and now let's talk about after we set up the
[00:41:32.940 → 00:41:39.340] optimization problem how can we solve this optimization problem okay so now what we'd like to do here is
[00:41:39.340 → 00:41:50.780] look at solving the optimization problem so graphically what this means here is again here we've got our
[00:41:50.780 → 00:41:56.460] linear plant right which is governed by x dot is equal to ax plus bu
[00:41:56.460 → 00:42:04.540] right and now what i want to do is i want to find a control law u here
[00:42:10.380 → 00:42:18.780] which is going to make this whole system here um optimal here right so i'm going to choose a u here
[00:42:18.780 → 00:42:24.860] so that the x uh by the time i look at the combination of u and x in that cost function it stays small
[00:42:24.860 → 00:42:31.580] according to the cost function that we set up here right so um it turns out that the solution to our
[00:42:31.580 → 00:42:39.340] problem here so i'll just write this down here so the solution to our optimization problem here right
[00:42:39.340 → 00:42:47.020] which was we said earlier minimize this cost function of integral zero to infinity of x transpose qx
[00:42:47.020 → 00:42:56.860] plus u transpose r u dt uh subject to these dynamics here right
[00:42:59.900 → 00:43:05.100] this was the optimization problem here well some really smart people figured it out it's beyond the
[00:43:05.100 → 00:43:10.620] scope of this lecture today to derive it here but i think we can use their results here the solution here
[00:43:10.620 → 00:43:22.780] is that you better choose a control here that looks like this minus k x of t where this gain k here is given by
[00:43:23.420 → 00:43:27.660] r inverse b transpose s here and s
[00:43:29.980 → 00:43:31.820] is the solution
[00:43:33.660 → 00:43:37.980] to what's called the algebraic ricotti
[00:43:37.980 → 00:43:43.020] equation of this so a
[00:43:44.540 → 00:43:56.860] transpose s plus s a minus s b r inverse or r inverse b transpose s plus q equals zero here right
[00:43:57.500 → 00:44:03.420] okay great um and here yeah s is the solution algebraic ricotti equation and also it is
[00:44:03.420 → 00:44:06.300] it's size n by n and square and symmetric
[00:44:09.340 → 00:44:15.100] okay so this is the solution here right so tell you what if we first if we first ignore everything
[00:44:15.100 → 00:44:21.100] below here just look at look at the solution here right the solution is minus kx we've seen that before
[00:44:21.100 → 00:44:25.500] this is just a full state feedback
[00:44:27.340 → 00:44:27.980] controller
[00:44:27.980 → 00:44:34.620] right so in other words the architecture that goes along with this is that this thing just looks
[00:44:34.620 → 00:44:34.940] like
[00:44:35.020 → 00:44:36.860] minus k
[00:44:38.220 → 00:44:45.900] right so the optimal thing to do the absolute best thing you can do to solve this problem is to use a
[00:44:45.900 → 00:44:52.940] full state feedback controller here now what gets interesting here is that the way you get this k here
[00:44:52.940 → 00:44:58.220] you have to go through a couple of steps here right if you look at this so step one here is we got to
[00:44:58.220 → 00:45:03.820] solve the algebraic ricotti equation for s here so let's talk about this the so the procedure
[00:45:07.260 → 00:45:13.180] for lqr right so step one here right we are going to be given
[00:45:13.180 → 00:45:24.220] our a and b matrix right those come from the plan right those are known right okay they're known and
[00:45:24.220 → 00:45:28.620] immutable you can't really change them the next thing we have to do here is you you are going to
[00:45:28.620 → 00:45:33.820] pick the q and the r right because you as a control designer you get to choose how much do i care about
[00:45:33.820 → 00:45:40.140] states versus how much do i care about control um actuation here right so you choose the the cost
[00:45:40.140 → 00:45:47.580] function effectively here right so um let's say step two is choose q and r right you're basically
[00:45:47.580 → 00:45:53.500] designing the cost function now according to this step three here is once i have q and r i need to
[00:45:53.500 → 00:46:00.300] solve the algebraic ricotti equation for s here right so solve i'm just going to abbreviate this as a
[00:46:00.300 → 00:46:07.260] r e here right so this down here is the algebraic ricotti equation here right okay so you solve the
[00:46:07.260 → 00:46:13.900] algebraic ricotti equation for s all right what you're going to end up seeing here is that once
[00:46:13.900 → 00:46:17.900] you solve for s there's actually going to be multiple solutions to s we'll take a look at this
[00:46:17.900 → 00:46:22.300] in a second here but if you follow a couple of steps you'll be able to find out which is the one
[00:46:22.300 → 00:46:27.420] you want here once you know that here um well actually no i take that back let's just say solve
[00:46:27.420 → 00:46:31.980] this thing for s you're going to get multiple solutions therefore you can then compute k you're
[00:46:31.980 → 00:46:37.980] going to get multiple solutions for k here right so you can go ahead and compute your optimal gain k
[00:46:39.660 → 00:46:45.740] using our expression over there right r inverse b transfer transfer transpose s here right and again
[00:46:45.740 → 00:46:50.780] since there are multiple solutions of s you'll get multiple solutions for k here the last thing that
[00:46:50.780 → 00:46:57.420] you have to do then is typically there's only going to be one solution here that yields a stable situation
[00:46:57.420 → 00:47:04.380] here so um if you remember earlier with this control of a full state feedback here right this
[00:47:04.380 → 00:47:12.940] thing is basically going to behave at the end of the day like x dot is equal to a minus bk x right and
[00:47:12.940 → 00:47:20.460] this here is like maybe you're you're a closed loop um uh a matrix here right again if if this is if this
[00:47:20.460 → 00:47:25.500] is brand new to you here maybe take a quick refresher here to our video where we discuss full state feedback
[00:47:25.500 → 00:47:31.180] controllers but we show that under this control law the dynamics reduced to this here right now what
[00:47:31.180 → 00:47:37.100] you can do here is you've got multiple k's here right so that means you have multiple a closed loops
[00:47:37.100 → 00:47:41.980] you can evaluate each of these eight closed loops and find its eigenvalues and usually there's only one
[00:47:41.980 → 00:47:47.020] of them that are going to have all poles in the uh or eigenvalues in the left half plane here so
[00:47:47.020 → 00:47:56.700] let me let's say step five here is choose um the case solution that yields
[00:47:59.340 → 00:48:00.380] a stable system
[00:48:04.860 → 00:48:10.940] yeah so that's the workflow that we need to go through so uh again i love concrete examples let's
[00:48:10.940 → 00:48:15.820] look at a concrete example right now to try to implement all this so the example i'd like to use
[00:48:15.820 → 00:48:24.780] here is a really simplified scenario it's a um a mass and a damper that's it okay so let's look at an
[00:48:24.780 → 00:48:35.340] example here of a mass uh slash damper system so you got some smooth surface like i don't know like
[00:48:35.340 → 00:48:40.380] some ice or something like that you got a mass sitting on this thing and all we're going to be doing
[00:48:40.380 → 00:48:47.100] here is let's consider the position and the velocity here like such positive position and positive
[00:48:47.100 → 00:48:53.260] velocity is to the right here and let's say that you have um a single control of this you're able to
[00:48:53.260 → 00:48:57.820] exert some kind of force on this block so you maybe have one rocket engine or one thruster that pushes
[00:48:57.820 → 00:49:06.780] this block along this ice here and here there's some viscous uh damping between the block and the the
[00:49:06.780 → 00:49:11.500] surface here all right so i think you can get without too much of a stretch of an imagination
[00:49:11.500 → 00:49:15.900] here that newton's second law equations of motions are going to basically give you mass times of a law
[00:49:15.900 → 00:49:23.260] uh mass times acceleration right is equal to the sum of all of the forces here right so you got the force
[00:49:23.260 → 00:49:32.620] here minus the retarding force of the um ice here right p times c or sorry c times p dot here
[00:49:32.620 → 00:49:40.380] right okay so without too much um sorry i guess we should say viscous damping with coefficient
[00:49:42.380 → 00:49:49.020] c right that's what this c is here it's just how much friction you got okay so um without too much of
[00:49:49.020 → 00:49:54.700] a of of a stretch i think you can turn this thing into a state space representation here by choosing a
[00:49:54.700 → 00:50:02.540] state vector x of t as let's make it the position and the velocity of the block that's our state vector
[00:50:02.540 → 00:50:06.540] and the control vector in this case is actually really really simple there's only one control
[00:50:06.540 → 00:50:16.140] it's this force right okay if you do this here you can basically get yourself a uh a state space
[00:50:16.140 → 00:50:31.180] representation of x dot of t is equal to uh zero one zero minus c over m x plus zero one over m u
[00:50:32.940 → 00:50:37.180] great that's our state space representation here's our a matrix here's our b matrix here
[00:50:37.180 → 00:50:41.740] let's go ahead and choose some numeric values so we can actually try to compute some of these here so
[00:50:41.740 → 00:50:49.340] let's go ahead and how about consider a mass of one and a coefficient of damp uh damping here of 0.2
[00:50:49.340 → 00:50:57.020] so numerically we end up with an a matrix that looks like 0 1 0 minus 1 5th here and a b matrix that
[00:50:57.020 → 00:51:04.460] looks like uh 0 1 okay something pretty simple now that is uh that's step one here right we got a and b
[00:51:04.460 → 00:51:12.300] okay step two here is let's choose q and r okay so i don't know let's pick like a q of just uh something
[00:51:12.300 → 00:51:16.620] really simple how about an identity matrix here later on we're going to look at some examples where
[00:51:16.620 → 00:51:23.740] they're not identities but uh okay q is identity matrix r i don't know let's choose something like
[00:51:23.740 → 00:51:31.900] 0.01 something like that okay great so we got step one and step two now done now we got to go ahead and
[00:51:31.900 → 00:51:37.980] solve ourselves the algebraic ricotti equation here so um that's a little bit of a pain in the neck here
[00:51:37.980 → 00:51:43.020] right because if you remember that's this long matrix equation we got to set it equal to zero and solve for
[00:51:43.020 → 00:51:49.580] s here so i don't want to do that on the board let's do actually steps three through five here
[00:51:49.580 → 00:51:54.540] let's just run over to mathematica and have it do this for us so we can um see how can we compute
[00:51:54.540 → 00:51:58.620] this gain k all right so i'm going to pause the video and i'll meet you over on mathematica all right
[00:51:58.620 → 00:52:03.820] so here we are in mathematica so why don't we go ahead and uh make a couple of notes here so what we
[00:52:03.820 → 00:52:10.300] would like to do now is demonstrate solving the ar the algebraic ricotti equation and computing
[00:52:10.300 → 00:52:19.100] uh and lqr controller k right that's our game plan here so we said uh let's first do step one right
[00:52:19.100 → 00:52:25.740] step one was define the a and b matrix right so i think what we said was a was just a very simple
[00:52:26.700 → 00:52:33.340] uh what was it zero one zero minus one fifth i think and then b was uh pretty simple zero and one
[00:52:33.340 → 00:52:41.500] okay there we go shift enter that guy and here's step one uh what was step two step two was go ahead
[00:52:41.500 → 00:52:49.500] and choose q and r right so i think in our situation we said that the q was just going to be a very simple
[00:52:49.500 → 00:52:57.900] identity matrix here and the r matrix is actually going to be a one by one um of one over 100 here so
[00:52:57.900 → 00:53:03.900] let me just define it here as a list of lists here it's just that mathematics has a little bit of
[00:53:03.900 → 00:53:10.220] trouble using uh the parentheses notation to make a one by one matrix here so i'm going to just
[00:53:10.220 → 00:53:17.660] explicitly make a one by one matrix here um okay shift enter both those um okay now we're on to step
[00:53:17.660 → 00:53:25.100] three we said which was solve the are right so just to refresh your memory here right um the the algebraic
[00:53:25.100 → 00:53:32.780] ricotti equation is given by what do we say was i think it was a transpose s plus sa minus s b
[00:53:33.500 → 00:53:45.500] whoops r inverse b transpose s plus q equals zero right so we want to solve this for s here right
[00:53:45.500 → 00:53:50.220] okay so let's just go ahead and compute the left hand side of that expression first so the left hand
[00:53:50.220 → 00:54:00.380] side here is what it's just transpose a times s plus s times a minus s times b times inverse of r
[00:54:01.180 → 00:54:10.060] uh times transpose of b times s plus q right so that's the left hand side here and maybe let's just
[00:54:10.060 → 00:54:18.060] simplify maybe let's put the simplify up here whoops did i spell that wrong simplify here right and let's
[00:54:18.060 → 00:54:25.580] just look at this thing in matrix form just to get an idea of this so uh wait a second oh i'm sorry
[00:54:25.580 → 00:54:34.540] here we should have defined s here right so um we we uh should know here that s is what it's a symmetric
[00:54:34.540 → 00:54:40.540] matrix here so there's gonna be an s11 and s12 and this is also going to be an s12 because it's symmetric
[00:54:40.540 → 00:54:45.500] and then we'll have an s22 so this is what s looks like here so maybe let's make a quick note of that here
[00:54:45.500 → 00:54:59.340] in the mathematical notebook here so uh define s as a symmetric matrix of size n by n right okay now
[00:54:59.340 → 00:55:08.780] this second step here is go ahead and solve the are okay so let's see uh shift enter this value of s here
[00:55:08.780 → 00:55:13.980] shift enter the right hand side here we go so here's what it looks like right so we see now we basically
[00:55:13.980 → 00:55:19.580] have um again this is actually a symmetric equation here right or symmetric matrix if you look this
[00:55:19.580 → 00:55:25.100] off diagonal entry is the exact same as this off diagonal entry here so really we have three
[00:55:25.100 → 00:55:32.700] equations and three unknowns right i need to find s11 s12 and s22 here right so what i need to really do
[00:55:32.700 → 00:55:39.740] now is i need to say solve basically the uh a bunch of equations right it's the left hand side the 11
[00:55:39.740 → 00:55:45.500] element right this has got to equal zero actually all of these entries have to equal zero so this has
[00:55:45.500 → 00:55:52.300] equal zero the left hand side of one two has got to also equal zero and the left hand side uh 22 has
[00:55:52.300 → 00:55:58.220] got to equal zero right so those are the this equation has got equal zero this has to equal zero and this
[00:55:58.220 → 00:56:06.220] has to equal zero here right those all solve them simultaneously for what s11 s12 and s22 right that's what i'm
[00:56:06.220 → 00:56:11.740] looking for here right so if i shift enter this you see that we actually have four solutions like we
[00:56:11.740 → 00:56:16.220] said earlier right that was to be expected we said that when you solve this for a lot of times they're
[00:56:16.220 → 00:56:22.460] going to be multiple solutions for s so let's just go ahead and um extract those here so maybe let's assign
[00:56:22.460 → 00:56:31.340] this to a temporary variable call it temp and um let's see here uh s um let me think about this how do we
[00:56:31.340 → 00:56:37.100] want to do this here uh you know actually we already defined s up here i i know what we'll do let's just do it
[00:56:37.100 → 00:56:45.420] like this here so um let's call this thing how about solution one gets a temp one so this is the first
[00:56:45.420 → 00:56:50.460] set of solutions here all right um let's do this for actually all four of them here right so let's get
[00:56:50.460 → 00:56:58.940] all four solutions here so let me see change this to a four three two and then solution two three four
[00:56:58.940 → 00:57:05.500] okay so here's our four solutions and what i want to do now here is make the four matrices here so s1
[00:57:05.500 → 00:57:11.260] is going to get s but i want to make all of these appropriate substitutions so i'll just say slash dot
[00:57:11.260 → 00:57:19.260] with solution one all right so here's s1 and great let's again do this for all four four three whoops four
[00:57:20.700 → 00:57:27.900] three two and then this should be two three four here and tell you what let's just go ahead and suppress
[00:57:27.900 → 00:57:33.820] the output for all these and then we will just look at these things as numerical values in matrix form
[00:57:33.820 → 00:57:43.980] just we can get a rough idea of what they look like oh sorry that should be s1 s2 s3 and s4 so we
[00:57:43.980 → 00:57:51.180] shift into those so we see here are the four solutions here to the algebraic ricotti equation so we need to
[00:57:51.180 → 00:57:57.340] now identify which one of these are the correct ones so let's move on to step four here step four which was
[00:57:57.340 → 00:58:07.020] compute k right and if you remember here we said that the way we compute k here was k um sorry excuse
[00:58:07.020 → 00:58:17.980] me uh k is going to be what it's r inverse b transpose times s here so we end up with four solutions here so
[00:58:17.980 → 00:58:27.100] let's do this here so k1 is inverse of r times transpose b times s1 here so that's the first
[00:58:27.100 → 00:58:31.180] possible solution and makes me let's do this let's make let's get all four of these guys
[00:58:33.340 → 00:58:42.860] two three four and then four three two okay great and then let's look at their actual values here for
[00:58:42.860 → 00:58:52.300] fun k1 slash slash um n slash matrix form and again let's look at all four of the different controllers
[00:58:52.300 → 00:58:57.500] that we've now computed here here we go so you can see they're they're they're very different here
[00:58:57.500 → 00:59:01.980] they have different signs they have different numeric values here so theoretically or at least
[00:59:01.980 → 00:59:06.220] mathematically all of these solve the problem but we know from an engineering standpoint here that they
[00:59:06.220 → 00:59:13.260] can't all work only the ones that have stable uh closed loop eigenvalues um actually will give us
[00:59:13.260 → 00:59:20.540] a system which goes back to the origin and therefore has minimum um minimum cost in our cost function so now
[00:59:20.540 → 00:59:27.740] step five here is we need to find solution that yields stable system so in other words what i want
[00:59:27.740 → 00:59:36.060] to do here is i want to look at the eigenvalues of a minus b k right and uh let's call this here here's my
[00:59:36.060 → 00:59:42.060] first set of eigenvalues is is lambda one and again let's just go ahead and do this for all of them
[00:59:42.060 → 00:59:54.780] all right so here's lambda two three four and this should be four three uh two okay and then let's just
[00:59:54.780 → 01:00:05.260] look at them all here so uh lambda one uh slash slash n and let's just do this for all of them we'll look
[01:00:05.260 → 01:00:10.940] at numerical values for all of these guys right so two three four all right shift enter that here we
[01:00:10.940 → 01:00:16.140] are so if you look at this okay obviously this one's out we got a positive poll we got a positive poll
[01:00:16.140 → 01:00:23.020] got two positive polls aha here we are it's actually the fourth solution here right the fourth solution
[01:00:23.020 → 01:00:30.140] gets you a controller which will yield negative um polls so we see that the solution here that we're
[01:00:30.140 → 01:00:36.140] looking for it's really k4 here so here's my controller here that should work a positive 10
[01:00:36.140 → 01:00:43.980] and a positive 10.75 okay great so we just did this in mathematica and we saw that basically this a b q
[01:00:43.980 → 01:00:49.660] and r matrix when you run it through the procedure yields a gain matrix k of what do we say this was
[01:00:49.660 → 01:00:58.220] this was 10 and 10.76 here right so perfect we designed our full state feedback controller using this
[01:00:58.220 → 01:01:02.220] technique but as you saw it's a little bit cumbersome right you got to go through all of these five
[01:01:02.780 → 01:01:10.780] um operations here luckily for us matlab has taken all of these operations here and packaged up it up
[01:01:10.780 → 01:01:18.860] into one function called lqr so if you pass lqr these necessary inputs right in other words you give it the a
[01:01:18.860 → 01:01:25.980] b the q and the r matrix this lqr function will basically go through this operation and return to you
[01:01:26.700 → 01:01:31.980] the gain matrix k it also i believe will give you the solution s here that we were solving for
[01:01:31.980 → 01:01:37.420] as well as the closed loop eigenvalues of your system here so in other words in matlab all you
[01:01:37.420 → 01:01:48.140] got to do here is call lqr pass it a b q and r and it will return to you k s and e here so again here k is
[01:01:48.140 → 01:01:59.820] going to be your um full state feedback gain matrix uh s is going to be the solution to the algebraic
[01:01:59.820 → 01:02:08.140] ricotti equation and e are going to be the eigenvalues of the closed loop system right a minus b k right
[01:02:08.780 → 01:02:14.700] great so what i'd like to do now here is lqr is as we see it's this it's this powerful tool here that's
[01:02:14.700 → 01:02:21.260] going to allow us to change the behavior of the controller k here right by specifying the q and
[01:02:21.260 → 01:02:26.060] the r here so i'd like to investigate now three scenarios so maybe let's make ourselves a little
[01:02:26.060 → 01:02:36.700] table here so scenario maybe with a description um and we'll see what is the resulting k here okay so
[01:02:36.700 → 01:02:41.420] let's make ourselves a little table here i'd like to investigate three scenarios one two three
[01:02:41.420 → 01:02:47.660] three so in the first scenario what i'd like to look at here is um let's go ahead and investigate
[01:02:47.660 → 01:03:04.780] the situation where control is cheap and a non-zero state is expensive right um and then in scenario two
[01:03:04.780 → 01:03:10.940] maybe let's get ourselves a little bit more room here scenario two let's look at sort of the opposite
[01:03:10.940 → 01:03:21.180] scenario here where control is expensive and a non-zero well maybe i shouldn't i mean let's write this out
[01:03:23.420 → 01:03:36.140] where a control is expensive and a non-zero state is cheap okay and then finally the third scenario here
[01:03:36.140 → 01:03:43.900] is let's let's let's mix this up a little bit let's say how about only a non-zero velocity
[01:03:45.900 → 01:03:46.700] is expensive
[01:03:49.980 → 01:03:57.820] okay so in this first scenario right you're saying uh that maybe um it i don't i really don't care how
[01:03:57.820 → 01:04:02.860] much control authority you have to exert i just really want to make sure that the state goes to zero
[01:04:02.860 → 01:04:07.820] quickly the second scenario is the exact opposite whereas maybe back to our satellite example where
[01:04:07.820 → 01:04:13.500] you're flying to mars here and and and fuel is extremely expensive but you have all the time in
[01:04:13.500 → 01:04:19.340] the world to kind of make sure that the the satellite returns to its appropriate orientation here and
[01:04:19.340 → 01:04:24.220] fine the third scenario is kind of interesting it's saying i only care about the velocity i want to make
[01:04:24.220 → 01:04:29.580] sure that the velocity doesn't um stay high i really don't care about the position here so what i'd like to
[01:04:29.580 → 01:04:34.460] do now is and actually maybe instead of k here first let's talk about translating this into an
[01:04:34.460 → 01:04:43.820] appropriate q and r matrix okay so you can kind of see in this first case where we're saying q uh
[01:04:43.820 → 01:04:50.060] control is cheap and non-zero state is expensive uh here that's almost like the scenario we just looked
[01:04:50.060 → 01:04:58.540] at here so with a q matrix of an identity matrix one one zero zero and an r matrix of zero point zero one
[01:04:58.540 → 01:05:04.700] right again all we care about is sort of the relative sizes so you can see here that r is much
[01:05:04.700 → 01:05:12.300] much smaller sort of relative to q so that should hopefully translate into a scenario where uh control
[01:05:12.300 → 01:05:18.620] is is cheap you have an aggressive controller here and in fact we saw let's write down exactly what the
[01:05:18.620 → 01:05:24.860] gain matrix k was coming out of this scenario here so we actually just solved this here so the k in this case
[01:05:24.860 → 01:05:33.340] was 10 and 10.76 right okay now let's look at the second scenario here where we would like to flip this
[01:05:33.340 → 01:05:39.580] so all we got to do now in this scenario is effectively sort of change the sizing the relative
[01:05:39.580 → 01:05:44.940] sizing of q and r so maybe let's keep q the same here so let's let's use another identity matrix
[01:05:46.300 → 01:05:52.620] but let's just jack up r we got to make r much bigger than uh than q effectively so maybe i don't
[01:05:52.620 → 01:05:58.460] let's let's go with a thousand here right and now the question is what is going to be k so we're
[01:05:58.460 → 01:06:02.460] going to run over to matlab and use lqr to do that before we go to matlab just so we don't have to break
[01:06:02.460 → 01:06:07.660] tempo so much let's fill in a q and an r for this third scenario here so in the case where we only want
[01:06:07.660 → 01:06:13.180] to penalize velocity here right we can kind of see that one way to do that here is by choosing your q
[01:06:13.180 → 01:06:19.260] matrix appropriately so for this q matrix what we would want to do here is if i only care about the the
[01:06:19.260 → 01:06:24.220] velocity being expensive i just got to make sure that the q entry that is associated with the second
[01:06:24.220 → 01:06:30.060] state is big relative to the q entry associated with the first state so maybe let's do something
[01:06:30.060 → 01:06:40.780] like this 0.001 and then uh 10. so as you can see here they're they are clearly um mismatched so the
[01:06:40.780 → 01:06:46.620] second state will be penalized orders and orders of magnitude more than the first state here right
[01:06:46.620 → 01:06:50.940] and then finally the r matrix i don't know let's just choose one here right because in this scenario
[01:06:50.940 → 01:06:55.660] all we want to show is the mismatch between the two states all right so now that we've set this up we've
[01:06:55.660 → 01:07:00.140] got all the different cues and the r's let's run over to matlab and have it basically we're just going
[01:07:00.140 → 01:07:07.980] to call lqr three times on each of these scenarios and see what the resulting matrix k is and then why
[01:07:07.980 → 01:07:13.100] don't we simulate that using uh our full state feedback controller right because we said that once you get
[01:07:13.100 → 01:07:18.300] this this this gain matrix k the optimal thing to do here is to have your plant right your x dot is
[01:07:18.300 → 01:07:26.940] equal to ax plus bu right and we're just going to wrap this back through a minus k and let's use some
[01:07:26.940 → 01:07:32.700] initial conditions i don't know maybe um in in here let's use initial conditions of uh what did i end up
[01:07:32.700 → 01:07:40.780] using here uh let me just make sure oh here's something like maybe let's make it pi and uh negative 2 here
[01:07:40.780 → 01:07:48.700] right so this is the position it's pi units away it's moving at negative 2 meters per second velocity
[01:07:48.700 → 01:07:53.980] here and let's see how fast this non-zero initial condition will be regulated to zero in these three
[01:07:53.980 → 01:07:59.180] different scenarios all right so here we are in matlab and i've actually already typed up this script just
[01:07:59.180 → 01:08:03.900] so you don't have to watch me inputting it in real time here um and we see that this is really simple all
[01:08:03.900 → 01:08:09.580] we're doing here is defining our a and b matrix as we had on the board and now the q and the r matrix we saw
[01:08:09.580 → 01:08:14.300] that the only difference between the three scenarios of where we either want cheap control
[01:08:14.300 → 01:08:19.420] expensive control or the scenario where we ignore the position and only care about velocity the only
[01:08:19.420 → 01:08:26.140] difference is the q and the r matrix right those were our tuning knobs to tailor the optimization problem
[01:08:26.140 → 01:08:31.100] for our specific desired application so i've just got a switch statement here where depending on what
[01:08:31.100 → 01:08:36.220] scenario we're investigating i will just load in and define the q and the r matrix that we discussed on
[01:08:36.220 → 01:08:42.940] the board once i've got the a b q and r matrix we saw that the entire l qr process is now packaged up
[01:08:42.940 → 01:08:48.860] into one nice function call in matlab namely l qr so i give it the a b q and r matrix and it will give me
[01:08:48.860 → 01:08:55.340] my full state feedback gain k the solution of the algebraic ricotti equation s as well as the eigenvalues
[01:08:55.340 → 01:09:00.700] of the closed loop system here so i'm just going to print that out to the screen so we can see what the
[01:09:00.700 → 01:09:05.820] the controller looks like and once i've got that defined we can think about running a simulation
[01:09:06.220 → 01:09:11.820] to examine how does the system respond under this controller so i've got um just a couple of
[01:09:11.820 → 01:09:15.340] parameters here like i'm going to change the final simulation time and then we're going to define
[01:09:15.340 → 01:09:20.540] the initial condition of this of the state space model as we discussed on the board here so let's
[01:09:20.540 → 01:09:26.460] build a simulink model now that will simulate this system i've got myself a blank uh simulink model here
[01:09:26.460 → 01:09:31.740] saved and ready to go so it's really simple the only thing i need to do here is first let's grab
[01:09:31.740 → 01:09:37.260] ourselves a state space block here and open it up and change the parameters to be a b and now the c
[01:09:37.260 → 01:09:43.820] matrix right this needs to be a uh identity matrix of size two and the zero uh the d matrix is what
[01:09:43.820 → 01:09:49.580] it's basically zeros of size two by one right all right so this here now is a state space system that
[01:09:49.580 → 01:09:54.460] we defined here where the output is just the state okay and we'll put in the initial conditions like
[01:09:54.460 → 01:10:00.620] we discussed earlier hit okay and now the controller in this case it's just a full state feedback
[01:10:00.620 → 01:10:06.620] controller so it's just really a simple gain here of magnitude minus k and i just need to change the
[01:10:06.620 → 01:10:12.140] multiplication from being element wise to being a matrix multiply and we basically have now maybe a
[01:10:12.140 → 01:10:17.340] better name for this instead of just gain here is this is our full state feedback controller computed
[01:10:18.060 → 01:10:26.540] via lqr right so this is my lqr controller effectively right so let's just hook everything up oh come on
[01:10:26.540 → 01:10:34.780] connect there we go connect this up together and we basically have our simulation ready to go um oh
[01:10:34.780 → 01:10:39.500] wait we should maybe change this for a simulation time let's make a t final like we discussed and
[01:10:39.500 → 01:10:47.100] also what we probably want to do is send this results back to matlab so we can analyze it so let's grab a
[01:10:47.100 → 01:10:54.540] two workspace block and i will change this to be sim x here and let's change the save format i just like
[01:10:54.540 → 01:11:03.180] structure with time better than time series and let's go ahead and save both the um the uh output
[01:11:03.180 → 01:11:09.340] state here and then you know we should also do is let's copy and paste this and we'll get another one
[01:11:09.340 → 01:11:17.020] which is going to be sim u and i think we should be good there and let's hook this up uh whoops sorry
[01:11:17.020 → 01:11:23.660] branch off and hold there we go save this guy we should be able to now close this model here it
[01:11:23.660 → 01:11:29.020] should be ready to go and now what i'm going to do here is let's just go ahead and simulate the system
[01:11:29.020 → 01:11:35.020] now all right so now let's just go ahead and run that simulation here so i'm going to call sim intro
[01:11:35.020 → 01:11:40.460] to lqr and once that simulation has finished let's go ahead and extract the data here right so time is
[01:11:40.460 → 01:11:49.020] going to be uh sim x dot time and then x1 is going to be sim x dot signals dot values all rows column 1
[01:11:49.020 → 01:11:57.180] here and let's do the same thing for x2 and u1 at the same time here so extract the second state and
[01:11:57.180 → 01:12:03.020] the first control here and now we've got those extracted we can go ahead and plot these right
[01:12:03.020 → 01:12:10.540] so let's go figure subplot 3 1 1 and let's plot time and x1 and let's make this a little bit thicker
[01:12:11.660 → 01:12:17.180] so we can see it a little bit more easily and we'll maybe add a legend as well just so we can
[01:12:17.180 → 01:12:23.740] discern which one is which and let's do the same thing for x2 and u1 while we're at it here
[01:12:26.220 → 01:12:33.420] and maybe what we should also do here is um let's add a title to this first subplot here
[01:12:33.420 → 01:12:35.580] so we can denote what the scenario is
[01:12:39.100 → 01:12:46.860] okay scenario there we go okay great so this looks pretty reasonable so let's go ahead and run this
[01:12:46.860 → 01:12:52.700] script here and first off we see yep this is the gain matrix k that we computed it's the same thing
[01:12:53.500 → 01:12:57.500] um that we computed manually let's go ahead and look at this solution of the algebraic ricotti equation
[01:12:57.500 → 01:13:01.500] and again this should be the exact same values that we got with our manual calculation in
[01:13:01.500 → 01:13:06.700] mathematica so this all looks pretty reasonable now let's look at the results here so remember this is
[01:13:06.700 → 01:13:13.420] the scenario here of cheap control so we see that what cheap control means here is that the system or
[01:13:13.420 → 01:13:19.020] the controller decides that i better make sure that the states go to zero fairly quickly so you see
[01:13:19.020 → 01:13:25.100] that in just five seconds both the position and the velocity of the system have gone to zero here
[01:13:25.100 → 01:13:31.340] and we spent around i don't know what is that minus nine minus 10 units of force in order to do that here
[01:13:31.980 → 01:13:37.660] so let's compare this now with maybe scenario two and maybe what we should do is let's keep this plot
[01:13:37.660 → 01:13:42.220] up so we can compare so maybe let's come to the top of our script here and temporarily comment out
[01:13:42.220 → 01:13:48.220] this close all command and let's just change our scenario now to scenario two here so scenario two
[01:13:48.220 → 01:13:54.860] is now let's tell the control system or tell the lqr procedure that control is really expensive now so
[01:13:54.860 → 01:14:03.020] if i run this again you see the k matrix now is smaller so we have a less aggressive controller here so
[01:14:03.020 → 01:14:09.180] if we look at this now here's scenario number two and if we compare that with scenario one maybe let's
[01:14:09.180 → 01:14:15.100] put scenario one on the left here and let's put scenario two on the right you can see the
[01:14:15.100 → 01:14:20.620] differences in control right so now the control system or the lqr procedure realizes that you know
[01:14:20.620 → 01:14:28.300] what um control is very expensive this is now like rocket fuel that is very uh costly so what i'm going
[01:14:28.300 → 01:14:33.740] to do is the controller is going to allow the state to be non-zero for a longer amount of time right so
[01:14:33.740 → 01:14:38.860] you see over here it takes almost 30 seconds for the position and the velocity of the block to come
[01:14:38.860 → 01:14:45.100] regulated back to zero but the benefit is if we compare the control that was expended here
[01:14:45.100 → 01:14:50.780] you can see the magnitude is much less right instead of having minus 10 units of force we're now we're
[01:14:50.780 → 01:14:57.980] now you know two orders of magnitude less here right and great now finally let's look at our third
[01:14:57.980 → 01:15:01.980] scenario here so i'll come back to the script here and change it to scenario three where we're going to
[01:15:01.980 → 01:15:08.220] now ignore position and if i rerun this thing again again you see that the controller changes and more
[01:15:08.220 → 01:15:14.540] importantly the behavior of that controller changes so now take a look at this this is pretty awesome
[01:15:14.540 → 01:15:20.060] the control system realizes that you know what i better make sure that the velocity goes to zero so
[01:15:20.060 → 01:15:25.260] it does that quickly but it doesn't give a hoot what the position is doing look at this the position
[01:15:25.260 → 01:15:31.420] is sitting here and still after 30 seconds it's nowhere near back to the origin but who cares right
[01:15:31.420 → 01:15:37.020] the controller realizes that the position does not factor into the cost function much at all so it's
[01:15:37.020 → 01:15:43.820] going to choose a control strategy that only pays attention to what matters namely the velocity and the
[01:15:43.820 → 01:15:49.500] control signal here so this is pretty awesome if you think about it we've now got a tool that's going to
[01:15:49.500 → 01:15:55.820] allow us to translate between physical requirements like which states and which controls do you care about
[01:15:55.820 → 01:16:01.580] and then synthesize a controller that will respond and respect those uh engineering requirements
[01:16:01.580 → 01:16:06.540] okay so that was pretty interesting exciting results so i think we can come here we can fill out our
[01:16:06.540 → 01:16:12.940] table here and finish this section here so again we saw the situation where control was cheap and a non-zero
[01:16:12.940 → 01:16:18.700] state was expensive we had this type of a controller come out of the lqr process but now when we
[01:16:18.700 → 01:16:27.180] change that r matrix we saw that the control was much less aggressive i think what 0.03 and 0.12 so
[01:16:27.180 → 01:16:32.380] yeah you can just look by the magnitude of these two you see that the second controller is is much
[01:16:32.380 → 01:16:37.420] more conservative right and then finally the third situation where we only cared about the velocity you
[01:16:37.420 → 01:16:41.100] know it's a little harder to interpret this controller here but i think we ended up with something like
[01:16:41.100 → 01:16:48.620] 0.03 and 2.98 here but again we might not be able to interpret directly what these numbers
[01:16:48.620 → 01:16:54.300] mean here but we saw the behavior was exactly what we wanted here right in the sense that the uh
[01:16:54.300 → 01:16:59.820] controller drives the velocity to zero fairly quickly but doesn't care so much about the position
[01:16:59.820 → 01:17:06.460] here right okay well this is uh we're really cooking with gas now so give me a chance to erase the board
[01:17:06.460 → 01:17:12.460] here and we'll come back and apply lqr in another way okay so now that we've got a rough handle on what
[01:17:12.460 → 01:17:23.100] lqr is and what it can do let's talk about how about using lqr to address some of these practical
[01:17:24.860 → 01:17:27.660] full state feedback control issues
[01:17:30.060 → 01:17:35.500] so if you remember this is actually what we discussed in uh our previous lecture here so again
[01:17:35.500 → 01:17:40.460] i i would encourage you to check out that video if you haven't done so here because i think it will set
[01:17:40.460 → 01:17:46.220] the stage for this discussion now and you'll have a better understanding of the context but um if you
[01:17:46.220 → 01:17:50.620] don't want to maybe just a real quick recap what we looked at last time where we were talking about
[01:17:50.620 → 01:17:55.900] full state feedback issues is we looked at a plant model here which was a uh a dc motor
[01:17:57.180 → 01:18:02.140] right and the idea with this plant model here was there were two control inputs there was a voltage on
[01:18:02.140 → 01:18:07.580] the armature of the motor as well as an external disturbance torque you could apply to the motor and what
[01:18:07.580 → 01:18:13.180] this thing did here is the full state of this system here was the position of the motor the velocity
[01:18:13.180 → 01:18:21.420] of the motor and the current of the motor here so um using this state vector x of just uh theta omega
[01:18:21.420 → 01:18:28.460] and i and a control vector u of just va and this tl which was the armature voltage and the torque here
[01:18:28.460 → 01:18:34.700] we saw that numerically you got an a matrix um that we were playing with it was a three by three here
[01:18:34.700 → 01:18:43.340] it looked like zero one zero zero minus zero point two nine and seventy one point nine three and then
[01:18:43.340 → 01:18:50.460] finally zero minus sixty three point two four and minus ten twenty point three five here and then your
[01:18:50.460 → 01:18:56.940] b matrix we actually we're just looking at the b1 here right the first column so what we did here in
[01:18:56.940 → 01:19:02.700] the example last time is forget about this external torque here pretend that this system only has one input
[01:19:02.700 → 01:19:08.060] which is the armature voltage therefore the b matrix only has one column and this is going to be zero zero
[01:19:08.620 → 01:19:15.660] uh 641.81 something like that right just to give you some numerical values that we can play with now
[01:19:15.660 → 01:19:23.420] right so this here is our model of this motor here right and what we said last time here right was that
[01:19:23.420 → 01:19:27.500] you could design a full state feedback controller for this system but we saw that we ended up with some
[01:19:27.500 → 01:19:33.020] issues right some of the issues we we encountered when designing a full state feedback control system
[01:19:33.020 → 01:19:45.740] was control saturation right and two was the inability to measure all states right you couldn't measure the
[01:19:45.740 → 01:19:50.780] full state uh every we didn't have a sensor for every single one of these i think we only had a sensor
[01:19:50.780 → 01:19:56.860] for for one of them right so last time we looked at some uh i don't know if i want to call them hacks
[01:19:56.860 → 01:20:02.220] here but they were they were ways that you could try to address these right we said that full state
[01:20:02.220 → 01:20:07.100] feedback controllers were incredibly powerful right but but as spider-man's uncle said right with great
[01:20:07.100 → 01:20:11.340] power comes great responsibility we have to deal with both of these issues here if we're trying to
[01:20:11.340 → 01:20:17.340] actually implement them right well lqr is going to give us a technique to directly address this so let's talk
[01:20:17.340 → 01:20:26.380] about how can i use lqr to address these two issues here right lqr is going to give us a perfect way to
[01:20:26.380 → 01:20:35.020] do this so let's look at first how about control saturation right i think the example we showed last
[01:20:35.020 → 01:20:39.580] time was that if you were if you naively went about trying to place the poles of your closed loop system
[01:20:39.580 → 01:20:47.260] right you could get controls which was in this case vas in terms of volts right this could spike
[01:20:47.260 → 01:20:51.740] and this could go down i think the situation we saw was this went down to like something like minus
[01:20:51.740 → 01:20:59.100] 90 volts right so you had this huge power requirement so so actually in this case it's
[01:20:59.100 → 01:21:05.420] it's with great power comes great electricity bills here right so what you know if ben parker was like
[01:21:05.420 → 01:21:10.380] peter uh you can't be doing this right our electricity is going through the roof peter parker should have
[01:21:10.380 → 01:21:16.620] just said oh geez sorry uncle ben next time why don't i i'll use an lqr controller to design my full state
[01:21:16.620 → 01:21:22.460] feedback system so it doesn't have this this problem right and we saw the way that that manifests itself
[01:21:22.460 → 01:21:29.740] here is that peter could just go ahead and vary the r matrix to make this thing um as aggressive or as
[01:21:29.740 → 01:21:37.980] conservative as he wants here right so what we can do here is the solution is just use the r matrix
[01:21:37.980 → 01:21:45.100] to uh tune quote unquote the aggressiveness
[01:21:48.780 → 01:21:55.660] of the controller so just as an example here i'm going to run some numbers here let's use a q matrix
[01:21:55.660 → 01:21:57.740] of just an identity matrix
[01:22:00.860 → 01:22:06.940] right and then the r matrix is just going to be a single value right let's call it an r11 here right
[01:22:06.940 → 01:22:13.260] and we see that all this is doing now is r11 or this r matrix we can tune how much do we care about
[01:22:13.260 → 01:22:18.460] this va measurement here right so let's just make a quick table to show what this ends up being here
[01:22:18.460 → 01:22:26.860] so let me r11 let's just make a couple of tables and then we'll look at the resulting uh k1 k2 and k3
[01:22:26.860 → 01:22:31.660] values that are going to come out of lqr so what we're going to do right now here is you could run over
[01:22:31.660 → 01:22:40.300] to matlab and you can say matlab hey lqr of a b q and r right and this is going to spit out the gain
[01:22:40.300 → 01:22:46.940] matrix k here right so i would just like to do a quick little study to see the how how sensitive is
[01:22:46.940 → 01:22:52.460] k2 r right if i change r how does this change the result in controller here right so i just ran a couple
[01:22:52.460 → 01:22:59.660] of numbers here so if you just turn 0.01 here you would get a k of 10 about also again around 10 and
[01:22:59.660 → 01:23:04.700] about 8.7 something like that so here's one controller and this might yield something like
[01:23:04.700 → 01:23:08.940] this right where you have huge power requirements well all you need to start doing then right is
[01:23:08.940 → 01:23:13.580] peter should have just sat here and cranked this number up and see what happens so if you crank up
[01:23:13.580 → 01:23:18.860] r you're basically saying control gets more expensive so what happens to the controller well
[01:23:18.860 → 01:23:25.500] it goes down right it starts getting smaller here right so you can see it's getting less aggressive and
[01:23:25.500 → 01:23:29.580] if and if and if and if uncle ben is still yelling at him for eat it for for costing him too much
[01:23:29.580 → 01:23:34.620] electricity he just cranks this thing up again right here so one you would get something like 1.0
[01:23:35.260 → 01:23:46.060] 0.93 and 0.34 right and then again you just for giggles let's crank it up even more so 0.32 0.25
[01:23:46.060 → 01:23:57.740] and 0.05 here right so you basically see we get this trend here as r increases right the aggressiveness
[01:23:57.740 → 01:24:10.220] of the controller decreases right decreases so we see r is this knob it's literally the knob of depending
[01:24:10.220 → 01:24:16.620] you can tell the system how much do you care about each different control um when trying to drive the
[01:24:16.620 → 01:24:21.900] state to zero great okay so that's one issue what about what about the second issue this inability to
[01:24:21.900 → 01:24:26.860] measure the full state of the system um maybe let's leave this up here let's just tell you what let's
[01:24:26.860 → 01:24:33.580] just erase this and we'll go back do the same thing here uh we'll start from this location and you can see
[01:24:33.580 → 01:24:41.660] that it's it's it's a very similar story here right so problem number two here right was the uh inability
[01:24:43.340 → 01:24:45.820] to measure full state
[01:24:51.820 → 01:24:58.540] so um unfortunately this is still a little bit nebulous even with lqr right so if you remember
[01:24:58.540 → 01:25:02.860] previously in our earlier discussion right what we attempted to do was we attempted to
[01:25:02.860 → 01:25:08.300] identify which eigenvalues were associated with which states here so let me write this down here
[01:25:08.300 → 01:25:16.460] maybe so previously right this is without lqr knowledge what we tried to do was tried to identify
[01:25:16.460 → 01:25:32.780] or id which eigenvalues uh were associated with which states and again let's put this word
[01:25:32.780 → 01:25:37.580] associated in quotes because we saw that you needed some eigenvector analysis to actually do this and
[01:25:38.220 → 01:25:44.620] for most systems the eigenvalues are coupled to multiple states so they're kind of tangled and you
[01:25:44.620 → 01:25:50.300] usually can't directly do this here right but we tried to do this here because what we wanted to do
[01:25:50.300 → 01:25:56.060] is once we identified which eigenvalues were roughly associated with which states we only tried to move
[01:25:56.060 → 01:26:02.060] those poles or those eigenvalues in the hopes that it would yield the control system which had which
[01:26:02.060 → 01:26:07.660] didn't require you to measure all of the states only to to uh measure the states or only to use the
[01:26:07.660 → 01:26:13.980] states which you could directly measure here right well luckily for us we can lqr is going to give us
[01:26:13.980 → 01:26:21.740] a tool to skip this here right because if you think about this now right with lqr right i don't care about
[01:26:21.740 → 01:26:28.300] the relationship between eigenvalues and states because i have a tool or a tuning button that will directly
[01:26:28.300 → 01:26:34.540] allow me to penalize states directly here so with lqr what i can do is i can use q right that q matrix
[01:26:35.180 → 01:26:48.380] to directly um specify which states are important
[01:26:48.380 → 01:26:58.140] or measurable in the sense that i have a sensor to measure certain states here right so now i don't
[01:26:58.140 → 01:27:05.180] need to do this eigenvalue to state mapping i can just use q to directly ask what states do i care
[01:27:05.180 → 01:27:10.220] about here right unfortunately this is still not a perfect solution here because there still is this
[01:27:10.220 → 01:27:16.060] coupling right so again let's go to an example here so for example what we might want to try now is
[01:27:16.060 → 01:27:22.140] this q matrix right let's just make this like a q 1 1 and then zeros everywhere else
[01:27:24.300 → 01:27:30.140] right because what we're saying here in this case is i only care about the first state which was
[01:27:30.140 → 01:27:36.380] the position of the motor which happened to be the only thing we directly measure here right so the hope
[01:27:36.380 → 01:27:43.900] here is that by just changing this value here or by only penalizing the state uh theta we're going to
[01:27:43.900 → 01:27:48.540] cross our fingers and hope that the lqr procedure is going to kick out a controller which doesn't
[01:27:48.540 → 01:27:55.660] really require me to use omega or i much here right again this is a little bit shooting from the hip
[01:27:55.660 → 01:27:59.980] here because it's not entirely true we're going to see that this this is a case here so tell you what
[01:27:59.980 → 01:28:06.540] let's use this q and an r of just one here right so in this case we can do our same thing let's make
[01:28:06.540 → 01:28:15.820] ourselves a little table here of what q 1 1 is right and then let's look at the resulting uh k1 k2 k3
[01:28:18.220 → 01:28:23.420] again by using our little our lqr technique right so shoot i didn't leave a lot of space here but you
[01:28:23.420 → 01:28:30.300] guys get what i'm saying right we're basically going to go here and say lqr of a b q and r and this is
[01:28:30.300 → 01:28:35.740] going to give me the k matrix here right but now this q is i'm only penalizing this first state here right
[01:28:35.740 → 01:28:41.420] so again you start here as a small q 0.01 or something like that you'd end up with this of
[01:28:41.980 → 01:28:51.900] 0.1 0.02 0.0014 here right and actually another quantity that might be useful in this discussion
[01:28:51.900 → 01:28:57.580] right remember what we're trying to do here is we're we're crossing our fingers and hoping that this k
[01:28:57.580 → 01:29:03.740] matrix you know we're trying to implement sorry we're trying to implement the control law the control
[01:29:04.300 → 01:29:10.460] which was va right is minus kx right what we would really like is if you write this thing out this
[01:29:10.460 → 01:29:20.060] is a minus k1 times theta minus k2 times omega minus k3 times i we're hoping that these k1 k2 and k3 are
[01:29:20.060 → 01:29:26.380] small with respect to k1 so that we can safely neglect them and we end up with a control law that is
[01:29:26.380 → 01:29:33.500] realizable in this case in the sense that it is gains multiplied by states that you actually measure
[01:29:33.500 → 01:29:37.900] here right so in other words we're hoping we can neglect these two so what might be useful here is
[01:29:37.900 → 01:29:45.660] we actually should maybe let's look at the ratio of of k2 over k1 and k3 over k1 so let's write that
[01:29:45.660 → 01:29:55.260] down so k2 over k1 uh 1 in this column and k2 over i'm sorry k3 this should be k3 over k1 right
[01:29:55.260 → 01:30:02.060] because this gives us an idea of how big are k2 and k3 relative to k1 here right so in this case
[01:30:02.060 → 01:30:13.500] i think you end up with this is about being 0.19 or 19 here and 0.014 here okay so in this case i
[01:30:13.500 → 01:30:18.220] don't know if i would say this is is is super great here because you see that the second gain is almost
[01:30:18.220 → 01:30:22.700] 20 percent of the first one yeah this third gain is nice i think you could safely neglect it because
[01:30:22.700 → 01:30:29.820] it's only 1.4 percent of it but um yeah tell you what let's start cranking up q1 here to say this is
[01:30:29.820 → 01:30:35.100] that that that that theta is the is really much more important so again we can keep working on this
[01:30:35.100 → 01:30:42.220] table here right so um move this up 0.1 here right so in this case you would get a k1 of 0.32
[01:30:43.340 → 01:30:52.300] 0.05 and 0.0037 here so in terms of fractions here this would be 0.17 and 0.
[01:30:52.300 → 01:30:58.140] 0.012 so it's going in the right direction right the importance is going down now it's only 17
[01:30:58.140 → 01:31:04.380] percent great let's keep cranking this up let's go 1.0 here right so if you go one you would get a
[01:31:04.380 → 01:31:12.940] k1 of actually one as well and then 0.13 and then 0.0092 so in terms of fractions here this is now
[01:31:12.940 → 01:31:19.420] only 13 percent here and now we're down to less than one percent so finally let's do one more just for
[01:31:19.420 → 01:31:27.340] giggles here right so crank k11 up to 10 here right so now you get something like 3.16 0.29
[01:31:28.060 → 01:31:38.380] and 0.02 here all right okay great and now we're down to 0.09 and 0.006 so here we are so you can
[01:31:38.380 → 01:31:44.380] kind of see that now in this regime down here i think this is getting safer to neglect k2 and k3
[01:31:44.380 → 01:31:49.820] because it's only 10 percent and less than one percent of the overall controller here so again
[01:31:49.820 → 01:31:56.300] we see that lqr gives us another tool to try to address this inability to measure full state but
[01:31:56.300 → 01:32:05.020] it's still not a uh a panacea here right we still get um some issues and there will be some error when
[01:32:05.020 → 01:32:10.220] you make this this this this this neglect here right when we neglect these other two terms
[01:32:10.220 → 01:32:16.620] you're basically knocking off 10 and 1 percent of of the controller kind of here right again you got
[01:32:16.620 → 01:32:20.700] to worry about what are they being multiplied by it's being multiplied by omega and i so
[01:32:21.740 → 01:32:30.380] this is again a little bit uh off the cuff here right okay so um this is pretty awesome i think i think
[01:32:30.380 → 01:32:35.020] we had a good discussion and maybe this is a good spot to leave it let's just quickly summarize what
[01:32:35.020 → 01:32:43.660] we ended up discussing today with our introduction to lqr so in terms of a summary all right
[01:32:47.340 → 01:32:54.300] what did we say we said um all right lqr we see it's a great way to generate generate a controller
[01:32:54.300 → 01:33:00.460] that's optimal here in the sense that it solves this optimization problem right we said that the whole deal
[01:33:00.460 → 01:33:06.300] with where lqr came from is we wanted to minimize this cost function j which was integral from zero to
[01:33:06.300 → 01:33:21.020] infinity of x transpose qx plus u transpose ru dt all right let me get rid of some of this other stuff
[01:33:22.940 → 01:33:28.780] so we can have a nice summary slide okay okay so we were minimizing this and we were picking
[01:33:28.780 → 01:33:36.860] um at first we were thinking about any control law or right your control can be anything but then we
[01:33:36.860 → 01:33:43.660] had to impose a constraint here that really your x's and your user not completely free they're
[01:33:43.660 → 01:33:49.740] coupled together and the way they're coupled together is just our our linear state transition equation
[01:33:52.540 → 01:33:58.220] right so you're basically saying you as a control engineer give me the q and the r here and this
[01:33:58.220 → 01:34:03.660] optimization problem needs to solve a controller that will respect the dynamics of the system here
[01:34:03.660 → 01:34:08.940] right and it turns out here that the optimal control for this situation that solves this problem here
[01:34:08.940 → 01:34:22.220] right so we'll write the optimal solution is this controller u of minus kx where k
[01:34:22.220 → 01:34:32.620] right is um r inverse b transpose s here and s is the solution to the algebraic ricotti equation that we talked
[01:34:32.620 → 01:34:39.100] about earlier right so we saw that the actual solution here is nothing more than a full state feedback
[01:34:39.100 → 01:34:46.300] controller where k is computed in a very particular fashion here right so what's so awesome about this
[01:34:46.300 → 01:35:00.860] uh lqr technique here is that as a control engineer right right lqr gives us two knobs to directly penalize
[01:35:00.860 → 01:35:09.340] states or controls right so as a control engineer you choose the q and the r matrix here right and then you
[01:35:09.340 → 01:35:16.220] run the lqr process here and it will will synthesize a controller for you which respects these uh this cost
[01:35:16.220 → 01:35:21.900] function here and tries to find something that is the best here right so q and r are much more helpful
[01:35:21.900 → 01:35:27.340] knobs to twist because they have direct physical interpretation right q will literally tell you which
[01:35:27.340 → 01:35:32.540] states you care about in your system and r is going to tell you which controls are important or cheap or
[01:35:32.540 → 01:35:39.980] expensive or or whatnot here right so um i think that's a good spot to leave it here uh i hope you enjoyed
[01:35:39.980 → 01:35:46.940] this video on lqr here some of these things set the stage for some of our uh future discussions namely
[01:35:46.940 → 01:35:52.540] linear state estimation um is one of the topics we're going to cover in the future so with that being
[01:35:52.540 → 01:35:57.340] said um if you like the video please subscribe to the channel because like i said we'll have these future
[01:35:57.340 → 01:36:03.420] discussions on other controls topics and other engineering uh issues in the future so i hope to catch
[01:36:03.420 → 01:36:09.260] you at one of these future videos bye
