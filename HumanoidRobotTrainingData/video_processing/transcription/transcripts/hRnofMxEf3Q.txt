hRnofMxEf3Q
https://www.youtube.com/watch?v=hRnofMxEf3Q
Unknown Category
Ah, the inverted pendulum. Getting one of these to work is a little bit of a rite of passage if you're studying engineering or more specifically control theory. The concept is fairly straightforward. We have a weight or in this case a simple metal rod that can move freely about an axis. And as you can see here, once the program stopped, it just freely fell over because it's in an unstable position when it's upright. But our job is to create a controller that takes in encoder values that is the angle in which this rod is pointing and then controls the stepper motor so that it stays upright. We won't try to do the swing up where it gets it into that position. We'll just assume that it starts in the upright position in our controller. We'll need to keep it there. The Arduino in this case is just going to act as an interface for us. It's going to read in values from the encoder and then send commands to control the stepper motor. All of our coding will be done in Python for the controller so that we can make pretty graphs and it will help us tune the controller more easily. So with that in mind, let's get started. A PID controller is an instrument device or code that uses feedback from a sensor to regulate a process or system. PID stands for proportional integral derivative, which describes how the feedback information is used to create a control signal for the process. If you would like to dive more into the theory behind PID controllers, I highly recommend checking out my previous video. In our system, we want our pendulum to sit upright, which we're going to call 180 degrees, and we'll use a PID controller to make that happen. The input to the controller is the error term, which is the difference between our desired set point and the actual sensor value or feedback. The output of the controller is used as the input signal to our process or plant. In this case, it will be how many degrees we want to move our stepper motor by. The process gives us some kind of value to measure. In this case, it is an encoder angle, which is used in the feedback loop to compute the error term. In some cases, we can mathematically model the process. Many inverted pendulums can be modeled if you know the weight, size and so on. However, in many real world situations, it is very difficult or impossible to model the system we want to control. So we turn to manual tuning methods for our controller. While there are several tuning methods, we'll stick with the most basic. First, we'll set the integral and derivative constants to zero and guess at some value for the proportional constant. With a Kp too low, we won't get anywhere near our set point. We then adjust it so that our output gets close to the set point with maybe some oscillations. From there, we tune Ki so that we oscillate around the set point without causing the system to become unstable. In many cases, a Pi controller is enough. However, we can often tune the Kd term to remove some of that overshoot. With Kp, Ki, and Kd set, we have a fully tuned system. Here, the output quickly approaches the set point without overshooting. We'll run some code on the Arduino. Remember that the Arduino is simply acting as an interface for us. It's not doing any of the actual control code for us. It's going to read in values from the encoder and send out information necessary to control the stepper motor. If we scroll down to the top here of our code, we are using the L6474. That's an STMicroelectronics code. That's a library for our Arduino that allows us to control the stepper motor. We're also using a library called rotary encoder that just gives us angle information from that coder. If we click over to the control comms interface file, scroll down a little bit. You can see we have an object here control comms and there should be two basic functions. Well, we have our constructor and our unit. We also have send observation, which sends information back to the PC. In our case, it's just the angle of the encoder as well as the angle of the stepper motor. In addition, we have receive action. This just waits for an action to come from the PC that says what to do. We're going to put in this our angle that we want to move the stepper motor by, say, for example, move by three degrees or negative three degrees in the opposite direction. So if we go to our main interface program here, scroll down to where we see setup, we configure everything. And then in loop, we simply wait for those actions to show up for us from the PC side. We move the stepper as requested, say, by a certain number of degrees. We get the encoder and stepper angles. We put those into an array and then we send that observation back to the PC. And that is our entire loop and how we're going to control our inverted pendulum on the Python or the PC side of things. We have our control comms interface. This is the PC version of that control comms HPP file that we looked at. In this case, we have a similar object called control comms. We can get a list of serial ports, which helps us figure out what we need to connect to. We can connect to our serial port, which opens up a connection to the Arduino board. We can close that connection. And then the important thing here is this step function for us. We give it an action and some sort of command, say, move by or move to or reset, which says to make whatever position the stepper motor is in home. That information gets sent to the Arduino. The Arduino performs that action and then returns an observation to us, which is a status. In this case, it's just some user defined code that we're not going to use very much. A timestamp, which is useful to see how long it takes to compute some things, whether it's terminated. Once again, we're not really using that here. And an observation. In this case, it's going to be the angle of the encoder and the angle of the stepper motor. You can see that code here where we send out the command along with the action. We wait for a response. We decode that in JSON format and then we return with those results. Here's the status timestamp terminated and our observation array. And this is just for testing down here. Now let's look at the actual PID controller code. This is the part we care about. I'm going to execute these cells, but I won't get into the code very much because I want to spend more time on tuning the controller where we fiddle with the constants in order to make the inverted pendulum work. So from the top here, we're just going to import some libraries. We're going to set our constants. In this case, my Arduino is connected to com six. I'm using a baud rate of 500 K and I have assigned a timeout of one second in case something doesn't work where I can't communicate with that Arduino board. I also set my debug level here so that I can get some information from my control comms Python library that I've created. We've got some communication constants that we will be using. In this case, we're going to be using stepper mode eight, which is eight divisions per step. And we have some commands we can send out, such as setting home, move to move by and setting our stepper mode. I'm going to close that connection to the Arduino. That's just a safety thing. Make sure it is actually closed and then I'm going to reopen that connection. So now I can talk to the Arduino board. First, I'm going to test the control to make sure that it actually moves. The idea here is that the stepper motor should be able to move fast enough such that it can recover from a, say, plus or minus 10 degree offset from being vertical. If we go back to our Arduino code here, you can see the configuration that I set up for the stepper motor. I'm using the ST microelectronics L6474 library, and I've set the acceleration to very high. It should get up to max speed very quickly. I've set the maximum speed to 5000, which is about half of their maximum. That seems to be a good compromise between giving me a very high speed that it can correct for a 10 degree offset from vertical while not being very jittery in its motion. So you want to find that balance. So I played with these parameters to find a good balance. Note that this can take some time. And I was just doing this by feel before moving on and tuning the PID controller. Once we verified that this control works, it's time to tune the controller. Here I've set up my K constants. Here's PID. Sometimes you will need a bias, which we just add to our output of the controller. In many cases, a P controller is fine and you just need a simple bias and this will do it. Sometimes you'll find that even with PID, there's a little bit of an offset. So you add a bias term. We may not need that for this particular project, but just keep that in mind. There are other constants that you should keep in mind. Our set point is 180. That's 180 degrees. That's the rod facing up. We're going to run this for, let's say, 5000 steps. That's a good indication of whether this is working or not. We have guard degrees here. So we want the rod at 180 degrees. At 160 degrees or 200 degrees, we assume that the rod has fell over far enough and it's a lost cause. And the program or in this case, this particular cell will just stop. We're going to do eight divisions per step. That seems to be, once again, a good balance between having the stepper motor move quickly while still giving us enough control without having a lot of jitter. We're going to store the metrics so that we can plot them later. The first thing we're going to do is set the stepper mode to those eight divisions per step. And then we're going to set home wherever the stepper motor is facing. We're going to call that zero degrees. We're going to send that out and get our first time step. Then we'll try to keep the pendulum in the upright position. This is the actual PID controller. We'll first take a step and get that observation. So we take a step by telling the stepper motor to move by some amount. This move degree starts off as zero and that's what gets updated as the output of our controller. When we get our response, we're going to unpack that response to get status, time step terminated and our observation, which is an array. We unpack that array here. The first element of that array is the encoder degrees, and that's what we really care about. The second is our stepper degrees. Note that you could create a dual PID controller here, whether that's an inner and outer or side by side controllers, where you can then try to keep your stepper motor in the same spot rather than rotating. But instead of doing two controllers, we're going to keep it very simple and just do our one controller. Consider that a challenge for you. If you want to take this further, try to keep the stepper motor in more or less one position rather than having it spin around that axis. We're going to calculate the time between this step and the previous to get our interval, which we need in some of our calculations. And then we're going to record the previous time step so that we can use it on the next iteration of this loop. Then we're going to calculate our PID terms. We'll first find the error, which is the difference between our set point and the current encoder degrees, which we got from the observation. This error term is going to be used in our proportional calculations where we just multiply it by K P. Next up, we get the integral term, which takes the integral term from last time. This starts at zero and we accumulate that value with the error times our interval. From there, we get our derivative term, which is the previous error subtracted from the current error and divided by our time interval. We then sum all of these terms up after we've multiplied them individually by their K constant. So integral gets multiplied by K I, derivative gets multiplied by K D. And as we saw earlier, error gets multiplied by K P or the proportional term. We also add this bias term. I would leave this at zero unless you absolutely need it. Try to solve everything else and get that working. If you still need that bias term, go ahead and add it. Finally, we save the error term for the next iteration. So we have that previous ready to go for our derivative calculation. Next, we're going to store these metrics in arrays so that we can plot them. And we're going to check if the encoder goes past one of our set guard angles. So if it's less than 160 or greater than what was it 200, I think. Yeah, 200. It's just going to stop the whole episode and break out of this loop. Finally, we're going to use matplotlib to plot a whole bunch of stuff for us. And we will take a look at that when we tune our controller. Before we tune, I'd like to show you where you can go to get this code. Head to github.com slash Sean email slash pendulum dash PID. All of the code that I'm showing you is in here. If you would like to try out your own version of this PID controller to control the inverted pendulum kit from ST micro electronics. Now, let's get to tuning our actual controller. As I mentioned earlier, the first thing we want to do is make sure that our stepper motor can recover from about plus or minus 10 degrees. So when I run this cell here, I'm going to offset this by about five or six degrees. See, oops, wrong way. Let's try that again. So it's moving at negative 90. So I'm going to hold it about here. Yes, it goes the other way. So that means the stepper motor is capable of correcting from that amount. Now let's get to tuning. I'm going to start off with one for the proportional and zero for the others. I'm just going to guess at one and let's see where that gets us. So I'm just going to hold this here and say go. Okay. So it looks like it's jittering a lot and then it's struggling to keep up at the. And there. Let's take a look at our output. Sure enough, there's a lot of oscillations, which means that our value for KP is a little too high. Let's try adjusting it. So we're going to go up here. Let's move it to 0.1 and let's try again. Okay. So there weren't as many oscillations there, but you could see it struggling to keep up. And if we look at our plot, sure enough, it never quite reaches our set point and it just kind of struggles to keep up. That means KP is too low. Let's try 0.5 about halfway in between. We'll run this again. Okay. Not bad. There's some oscillations. And in fact, I want to run this again. Be prepared to run some of these cells multiple times. Okay. Still some oscillations. It's oscillating around that 180 point. So it means it's a little too high. Still let's bring it down just a notch. We're going to take it to 0.3. Let's see what happens. Oh, that's really good. That keeps it for a while. Not much on the oscillations and it's just struggling to keep up. This is what we want. We want the integral term to make up this difference. This is that steady state offset between where the set point is and where it's trying to get to or as best as it can get. So we're going to keep it at 0.3 and see if we can get to KI, our integral term, to make up that difference. I'm going to guess at 0.1. It usually starts much lower than KP. So let's try that and see what happens. Oh, what just happened there? Let's try that again. Oh, it's oscillating badly and then it whips around. Let's go take a look at our plot. And here we go. Sure enough, it's unstable. You can see it bouncing back and forth and getting larger and larger before it loses control. That's unstable. That means that KI is definitely too large. Let's move exponentially here. So rather than say having this, let's go to 0.01 and see what happens. Oh wow. That's really good. Actually. That's almost where we want it. Still look like it's oscillating some. So let's stop that. Go take a look at our code. Yeah, there's still some oscillations here. I don't see it hitting up too high in the beginning and then it's oscillating a bit. Let's see if we can bring that down just a little bit. And in fact, let's go probably too low and see what happens. Start it here. That's not bad at all. Oh, it's losing it here. Okay. So something between 0.01, excuse me, 0.001 and 0.1 looks to be ideal. So let's say 0.005 for the sake of argument and try that. Oh, that's yes. This is what we're looking for. It's barely moving and it's keeping it upright and I can touch it and it corrects. And let's see if it recovers from that. Oh, I got to touch the other way before that gets too wound up around that axle. And then it goes the other way. So there's some larger level oscillations going on in here, but this should be okay. Let's scroll up. Yeah, 0.005 seems to be really good. Now we can take some time and really tune these, but I think with a KP of 0.3 and a KI of 0.005, gonna be good enough for now and our demonstration. As you can see, this PI controller pretty much does the job for us. We probably don't even need a derivative term in here, but let's just play with it and see what happens. We started with zero, which is a good place to start. I'm gonna guess 0.1 just to see what happens. Once again, this is usually lower than the KP term. So let's try this. This is actually not too bad. Okay. Let's take this down. And take a look at our graph here. It's looking pretty good. And just for argument, what if we take it to 0.5? What happens? This thing's still a beast. It's still going. Looks like it's a little unstable. We're getting some of those oscillations, which is probably fine for this. Okay. That's fine. And just so you can see what happens when we really crank this up, let's take it to five and really try to make this too high. Yeah, there we go. We're getting too many of the oscillations and it's pretty unstable. It can't control it. So that means we are suppressing KI and KP a little too much. And sure enough, you can see it with this encoder angle. It's struggling here. Okay. So we know we got to be less than five. And what happens if we take it really low like point zero zero one? Once again, it's pretty good. We can't really go too low with this. I'm going to stop it there. We can't really go too low. We can't really go too low. All we're trying to do is suppress this peak here or any of the peaks where it overshoots our set point. And in this particular system, an inverted pendulum, we don't mind a little bit of overshoot. Sometimes you can't have this overshoot. So you need KD to suppress that. But for our system, it looks like anything between like zero and one is probably fine for your KD. So I'm going to maybe make it a little higher. I'm going to make it a little higher as we saw with one is not too bad. Five was too high. Let's see what happens with one. Yeah, that's pretty good. There's still a little bit of jitter happening here. But once again, I don't think that's because of the KD term. Yeah, this is really good. It's moving back and forth. It's accomplishing its purpose of keeping the pendulum upright. And from that, I think we can safely assume we have a fully tuned PID controller for our inverted pendulum. If we go and look at our plots, you can see the encoder angle stayed pretty static the whole time. There's a little bit of an overshoot by about two and a half degrees on that first one, but it's really not bad. And you can see the stepper slowly oscillating back and forth. That's something that can be corrected with a dual or nested PID controller, but not something we're going to get into right now. Just so you see what happens, we're going to leave bias at zero. It actually works very well. Let's try 10 for the bias term and see what happens. So I'm going to. Yeah, exactly. Nothing. It's trying to overcorrect for something. That's not even a problem. We might be able to bring this down. Let's say five. Okay. It's still working. It's not particularly great. As you saw, there's no real need for this bias term in this. So I'm just going to leave this at zero. Let's put this bias term back at zero and we're going to call this pretty tuned for our needs. As you can see, it works pretty much most of the time. It will move back and forth a little bit. And that's something that could be corrected with additional control schemes. But for now, I'm going to call this good enough. I think we can say we have a fully tuned system. There's obviously some other tweaks, but let's go with that for now. I hope this helps you get started creating your own PID controllers and then tuning them for things like inverted pendulums or self-balancing robots. Obviously there are more complex control schemes out there, such as linear quadratic regulators and model predictive control. But PID controllers are a great introduction into control theory. If this is something you would like to tinker with. Good luck and happy hacking. Beep! Boop!